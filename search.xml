<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>新手github常用命令教程</title>
    <url>/2023/06/23/GitHub/%E6%96%B0%E6%89%8Bgithub%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="无仓库，新建一个仓库并上传代码"><a href="#无仓库，新建一个仓库并上传代码" class="headerlink" title="无仓库，新建一个仓库并上传代码"></a>无仓库，新建一个仓库并上传代码</h2><p>1.在 GitHub 上创建一个新的仓库。在 GitHub 网站上登录并点击右上角的加号图标，选择 “New repository” 创建一个新的仓库。给仓库起一个名称，并选择是否设为公开或私有。</p>
<p>2.在本地项目中初始化 Git 仓库。打开你的项目文件夹，在命令行中执行以下命令来初始化 Git 仓库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure>

<p>3.将项目文件添加到 Git 仓库。使用以下命令将所有文件添加到 Git 仓库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add .</span><br></pre></td></tr></table></figure>

<p>4.如果你只想添加特定的文件，可以使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add 文件名</span><br></pre></td></tr></table></figure>

<p>5.提交你的更改。使用以下命令提交你的更改，并添加一个提交消息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git commit -m <span class="string">&quot;提交消息&quot;</span></span><br></pre></td></tr></table></figure>

<p>6.将本地仓库与远程仓库关联。在 GitHub 上创建的仓库中，复制仓库的远程 URL。然后，在命令行中执行以下命令将本地仓库与远程仓库关联：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git remote add origin 远程仓库URL</span><br></pre></td></tr></table></figure>

<p>7.将远程仓库URL替换为你复制的远程仓库 URL。</p>
<p>8.推送代码到远程仓库。使用以下命令将代码推送到远程仓库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push -u origin master</span><br></pre></td></tr></table></figure>
<h2 id="已有仓库，拉取项目到本地"><a href="#已有仓库，拉取项目到本地" class="headerlink" title="已有仓库，拉取项目到本地"></a>已有仓库，拉取项目到本地</h2><p>1.在本地项目中，使用以下命令将远程仓库与本地仓库关联：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git remote add origin 远程仓库URL</span><br></pre></td></tr></table></figure>

<p>2.将远程仓库URL替换为你的远程仓库的 URL。</p>
<p>3.使用以下命令将远程仓库的代码拉取到本地仓库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git pull origin master</span><br></pre></td></tr></table></figure>

<h2 id="更新已上传过的项目"><a href="#更新已上传过的项目" class="headerlink" title="更新已上传过的项目"></a>更新已上传过的项目</h2><p>1.确保项目路径自上次上传后没有变更，在项目路径中输入命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add .</span><br><span class="line">$ git commit -m <span class="string">&quot;提交消息&quot;</span></span><br></pre></td></tr></table></figure>

<p>2.使用以下命令将本地仓库的更改推送到远程仓库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure>

<h1 id="7月6日更新"><a href="#7月6日更新" class="headerlink" title="7月6日更新"></a>7月6日更新</h1><h2 id="查看当前仓库"><a href="#查看当前仓库" class="headerlink" title="查看当前仓库"></a>查看当前仓库</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git remote -v</span><br></pre></td></tr></table></figure>

<h2 id="更改仓库url"><a href="#更改仓库url" class="headerlink" title="更改仓库url"></a>更改仓库url</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git remote set-url origin &lt;new-url&gt;</span><br></pre></td></tr></table></figure>

<h2 id="列出本地仓库中的分支"><a href="#列出本地仓库中的分支" class="headerlink" title="列出本地仓库中的分支"></a>列出本地仓库中的分支</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch </span><br><span class="line"></span><br><span class="line">$ git branch -v  //可以查看提交信息</span><br></pre></td></tr></table></figure>

<h2 id="切换到不同的分支或恢复文件的状态"><a href="#切换到不同的分支或恢复文件的状态" class="headerlink" title="切换到不同的分支或恢复文件的状态"></a>切换到不同的分支或恢复文件的状态</h2><ol>
<li><p>切换到已存在的分支：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout &lt;branch-name&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建并切换到新分支：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout -b &lt;new-branch-name&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>恢复单个文件到最新提交状态：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout -- &lt;file-name&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>恢复整个目录到最新提交状态：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout -- &lt;directory-name&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>注意：在切换分支或恢复文件时，确保没有未提交的更改，否则可能会导致更改的丢失。</p>
]]></content>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql进阶篇 一</title>
    <url>/2023/07/05/mysql%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<h2 id="1-索引"><a href="#1-索引" class="headerlink" title="1.索引"></a>1.索引</h2><h3 id="1-基础语法"><a href="#1-基础语法" class="headerlink" title="1.基础语法"></a>1.基础语法</h3><p>索引是一种数据结构，用于加快数据的检索速度。常见的索引类型包括B树索引和哈希索引。在创建表时，可以为某些列添加索引来提高查询效率。</p>
<p>要为MySQL表添加索引，可以使用以下语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> INDEX index_name (column1, column2, ...);</span><br></pre></td></tr></table></figure>

<p>例如，如果要为名为<code>users</code>的表的<code>username</code>列添加一个名为<code>idx_username</code>的索引，可以使用以下语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> users <span class="keyword">ADD</span> INDEX idx_username (username);</span><br></pre></td></tr></table></figure>

<p>还可以为多个列同时添加索引，例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> users <span class="keyword">ADD</span> INDEX idx_username_email (username, email);</span><br></pre></td></tr></table></figure>

<p>此外，还可以使用<code>UNIQUE</code>关键字来创建唯一索引，确保索引列的值唯一：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> users <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> INDEX idx_username (username);</span><br></pre></td></tr></table></figure>

<p>需要注意的是，添加索引会增加写操作的开销，因为每次更新索引列时，还需要更新索引。因此，应该谨慎选择需要添加索引的列，避免过多的索引影响性能。</p>
<p>另外，还可以使用</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> table_name</span><br></pre></td></tr></table></figure>

<p>语句来查看表的索引信息，以及使用</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> INDEX index_name <span class="keyword">ON</span> table_name</span><br></pre></td></tr></table></figure>

<p>语句来删除索引。</p>
<h3 id="2-影响与使用"><a href="#2-影响与使用" class="headerlink" title="2.影响与使用"></a>2.影响与使用</h3><p>查询语句正常使用就行</p>
<ul>
<li>WHERE子句：在查询语句的WHERE子句中使用索引列，可以帮助MySQL快速定位符合条件的数据。例如，如果有一个名为<code>idx_username</code>的索引，可以使用以下查询：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> username <span class="operator">=</span> <span class="string">&#x27;john&#x27;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>ORDER BY子句：当使用ORDER BY子句对查询结果进行排序时，如果排序的列上有索引，MySQL可以使用索引来加速排序过程。例如，如果有一个名为<code>idx_created_at</code>的索引，可以使用以下查询：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">ORDER</span> <span class="keyword">BY</span> created_at;</span><br></pre></td></tr></table></figure>

<ul>
<li>JOIN操作：当进行JOIN操作时，可以使用索引来加速关联表的过程。确保参与JOIN操作的列上有索引，可以提高查询性能。例如，如果有一个名为<code>idx_user_id</code>的索引，可以使用以下查询：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">JOIN</span> orders <span class="keyword">ON</span> users.id <span class="operator">=</span> orders.user_id;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>避免索引失效：有些情况下，即使有索引，MySQL也可能选择不使用索引，导致查询性能下降。一些常见的情况包括使用函数或表达式对索引列进行操作，使用OR运算符连接多个条件等。尽量避免这些情况，以确保索引能够发挥作用。</p>
</li>
<li><p>EXPLAIN语句：使用<code>EXPLAIN</code>语句可以分析查询语句的执行计划，包括是否使用了索引。通过查看执行计划，可以判断是否需要优化查询语句或添加索引。</p>
</li>
<li><p>索引选择：在设计表结构时，根据查询的需求和频率选择合适的索引。选择具有较高选择性的列作为索引列，避免过多的索引影响写操作性能。</p>
</li>
</ul>
<p>需要注意的是，虽然索引可以提高查询性能，但过多的索引也会增加写操作的开销，并占用额外的存储空间。因此，需要权衡索引的使用和性能的平衡。</p>
<h2 id="2-事务"><a href="#2-事务" class="headerlink" title="2.事务"></a>2.事务</h2><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h3><p>事务是一组数据库操作的集合，这些操作要么全部成功执行，要么全部回滚。事务具有以下四个特性（通常称为ACID特性）：</p>
<ol>
<li><u>原子性（Atomicity）：事务中的所有操作要么全部成功执行，要么全部失败回滚。如果事务中的任何一条操作失败，那么整个事务都会被回滚到之前的状态，不会对数据库造成影响。</u></li>
<li>一致性（Consistency）：事务执行前和执行后，数据库的状态都必须保持一致。事务中的操作不会破坏数据库的完整性约束，如主键、外键、唯一性约束等。</li>
<li><u>隔离性（Isolation）：每个事务的操作都应该与其他事务的操作相互隔离，互不干扰。一个事务的中间结果对其他事务是不可见的，直到事务提交才能对其他事务可见。</u></li>
<li>持久性（Durability）：一旦事务提交，其对数据库的修改应该是永久性的，即使发生系统故障或重启，修改的结果也应该得以保留。</li>
</ol>
<p>注：<u>同一会话只能存在一个事务</u></p>
<h3 id="2-原子性的意义"><a href="#2-原子性的意义" class="headerlink" title="2.原子性的意义"></a>2.原子性的意义</h3><p>原子性在许多应用场景中都是非常重要的，以下是一些经典案例，展示了需要原子性的情况：</p>
<ol>
<li>转账操作：在银行系统或支付系统中，转账操作是一个典型的需要原子性保证的场景。转账涉及从一个账户扣除一定金额并将其添加到另一个账户，必须保证这两个操作要么同时成功，要么同时失败，<u>以避免出现一方扣款而另一方未收到款项的情况</u>。</li>
<li>订单处理：在电子商务系统中，订单处理通常涉及多个步骤，如扣减库存、生成发货单、更新订单状态等。这些操作必须作为一个原子性的事务进行，以确保订单处理的一致性和完整性。</li>
<li>数据库更新：在数据库中进行复杂的数据更新操作时，如批量插入、批量修改或批量删除，需要保证这些操作要么全部成功，要么全部回滚，<u>以避免部分数据更新成功而部分数据更新失败的情况</u>。</li>
</ol>
<h3 id="3-事务的隔离性"><a href="#3-事务的隔离性" class="headerlink" title="3.事务的隔离性"></a>3.事务的隔离性</h3><p>首先需要了解几个可能出现的情况</p>
<h4 id="1-脏读（Dirty-Read）"><a href="#1-脏读（Dirty-Read）" class="headerlink" title="1.脏读（Dirty Read）"></a>1.脏读（Dirty Read）</h4><p>指一个事务读取了另一个未提交事务的数据。<u>当一个事务对数据进行修改但尚未提交时，另一个事务读取了这些未提交的数据，导致读取到了不一致或无效的数据。</u></p>
<p>脏读可能会导致数据的不一致性和错误的结果。当未提交的事务回滚时，读取到的数据实际上是不存在的，这可能会引发误解和错误的判断。</p>
<h4 id="2-幻读（Phantom-Read）"><a href="#2-幻读（Phantom-Read）" class="headerlink" title="2.幻读（Phantom Read）"></a>2.幻读（Phantom Read）</h4><p>指在一个事务中，当多次执行同一个查询时，可能会看到不一致的行数或数据集合的情况。</p>
<p>当一个事务在读取某个范围的数据时，另一个事务在该范围内插入了新的行或删除了现有的行。由于范围内的数据发生了变化，第一个事务再次执行同一个查询时，会看到不一致的行数或数据集合，就好像出现了幻觉一样，这就是幻读。</p>
<h4 id="3-不可重复读（Non-Repeatable-Read）"><a href="#3-不可重复读（Non-Repeatable-Read）" class="headerlink" title="3.不可重复读（Non-Repeatable Read）"></a>3.不可重复读（Non-Repeatable Read）</h4><p>指在一个事务中，多次执行同一个查询，可能会看到不同的数据值。</p>
<p>当一个事务在读取某个数据后，另一个事务对该数据进行了修改并提交后，第一个事务再次读取同一个数据时，可能会看到不同的数据值。</p>
<h4 id="4-三者区别"><a href="#4-三者区别" class="headerlink" title="4.三者区别"></a>4.三者区别</h4><table>
<thead>
<tr>
<th align="left">情况</th>
<th align="left">产生时机</th>
<th align="left">影响</th>
</tr>
</thead>
<tbody><tr>
<td align="left">脏读</td>
<td align="left">一个事务读取了另一个未提交事务的数据时</td>
<td align="left">可能会读取到不一致或无效的数据值</td>
</tr>
<tr>
<td align="left">幻读</td>
<td align="left">一个事务读取某个数据范围时，另一个事务在该范围内插入了新的行或删除了现有的行</td>
<td align="left">可能会读取到不一致的行数或数据集合</td>
</tr>
<tr>
<td align="left">不可重复读</td>
<td align="left">一个事务在读取某个数据后，另一个事务对该数据进行了修改并提交后，第一个事务再次读取同一个数据时</td>
<td align="left">可能会读取到不一致数据值。</td>
</tr>
</tbody></table>
<h4 id="5-事务的隔离级别"><a href="#5-事务的隔离级别" class="headerlink" title="5.事务的隔离级别"></a>5.事务的隔离级别</h4><p>事务隔离级别（Transaction Isolation Level）是指在并发情况下，一个事务对于其他事务的可见性和影响范围的控制程度。MySQL支持多个事务隔离级别，每个级别都有不同的特性和权衡。</p>
<p>以下是四个常见的事务隔离级别：</p>
<ol>
<li>Read Uncommitted（读未提交）：最低的隔离级别，事务可以读取其他事务未提交的数据。这种级别存在脏读的问题，可能导致不一致的数据。</li>
<li>Read Committed（读已提交）：保证一个事务只能读取其他事务已提交的数据。这种级别避免了脏读的问题，但仍然可能出现不可重复读和幻读的问题。</li>
<li>Repeatable Read（可重复读）：事务之间可以并发执行，但通过使用多版本并发控制（MVCC）来保证数据的一致性。每个事务在读取数据时会创建一个快照，并在事务执行期间保持一致。这种级别避免了脏读和不可重复读的问题，一定程度上解决了幻读问题，但并不完全。</li>
<li>Serializable（串行化）：最高的隔离级别，通过对事务进行串行化执行来避免并发问题。后一个事务必须等待前一个事务执行完成，事务之间完全隔离，避免了脏读、不可重复读和幻读的问题。但由于串行化执行，可能导致性能下降。</li>
</ol>
<p>不同的隔离级别在提供数据一致性和并发性之间存在权衡。更高的隔离级别通常提供更好的数据一致性，但可能降低并发性能。选择适当的隔离级别应根据具体的业务需求和性能要求进行评估。</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>解决问题</th>
<th>存在问题</th>
</tr>
</thead>
<tbody><tr>
<td>读未提交</td>
<td>-</td>
<td>脏读</td>
</tr>
<tr>
<td>读已提交</td>
<td>脏读</td>
<td>不可重复读、幻读</td>
</tr>
<tr>
<td>可重复读</td>
<td>脏读、不可重复读</td>
<td>可能会幻读</td>
</tr>
<tr>
<td>串行化</td>
<td>脏读、不可重复读和幻读</td>
<td>并发性能差</td>
</tr>
</tbody></table>
<h3 id="4-语法"><a href="#4-语法" class="headerlink" title="4.语法"></a>4.语法</h3><p>在MySQL中，可以使用以下语句来定义和控制事务：</p>
<ol>
<li>开始事务：使用<code>START TRANSACTION</code>或<code>BEGIN</code>语句来开始一个事务。</li>
<li>提交事务：使用<code>COMMIT</code>语句来提交事务，将事务中的操作永久保存到数据库。</li>
<li>回滚事务：使用<code>ROLLBACK</code>语句来回滚事务，撤销事务中的操作，恢复到事务开始前的状态。</li>
<li>设置隔离级别：可以使用<code>SET TRANSACTION ISOLATION LEVEL</code>语句来设置事务的隔离级别。如<code>READ UNCOMMITTED</code>、<code>READ COMMITTED</code>、<code>REPEATABLE READ</code>和<code>SERIALIZABLE</code>。</li>
</ol>
<p>使用一个事务：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">100</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">100</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<p>回滚一个事务：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">100</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">100</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure>

<p>设置全局隔离级别：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> TRANSACTION ISOLATION LEVEL isolation_level;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</span><br></pre></td></tr></table></figure>

<p>设置会话隔离级别：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL isolation_level;</span><br></pre></td></tr></table></figure>

<p>查看事务的当前隔离级别：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@tx_isolation</span>;</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@session</span>.tx_isolation;</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@global</span>.tx_isolation;</span><br></pre></td></tr></table></figure>

<p>可以使用保存点（Savepoint）来模拟子事务的行为。保存点是在事务中设置的一个标记，可以在事务执行期间进行回滚到该标记的位置。通过使用保存点，可以在事务中创建多个逻辑上的子事务，并在需要时回滚到保存点。</p>
<ol>
<li>在事务开始时，使用<code>SAVEPOINT</code>语句创建一个保存点：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SAVEPOINT</span> savepoint_name;</span><br></pre></td></tr></table></figure>

<p>在事务执行期间，执行一系列SQL操作，这些操作可以被视为子事务的逻辑。</p>
<p>如果在子事务中发生错误或者需要回滚，可以回滚到保存点：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> <span class="keyword">SAVEPOINT</span> savepoint_name;</span><br></pre></td></tr></table></figure>

<p>如果子事务执行成功，可以继续执行其他操作。</p>
<p>最终，通过使用<code>COMMIT</code>语句提交整个事务，或者使用<code>ROLLBACK</code>语句回滚整个事务。</p>
<p><u>虽然使用保存点可以模拟子事务的行为，但它并不是真正的子事务。在MySQL中，事务的提交或回滚是整体性的，无法对部分操作进行提交或回滚。</u></p>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>wx.getUserProfile 不出现弹窗</title>
    <url>/2023/06/23/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/wx-getUserProfile-%E4%B8%8D%E5%87%BA%E7%8E%B0%E5%BC%B9%E7%AA%97/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>使用wx.getUserProfile 获取用户信息，但是不出现弹窗就直接获取到了用户信息，且返回灰色头像，和“微信用户”昵称</p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>原来这个接口在22年5月的时候被回收了，低版本调试库才会正常显示，高版本则会返回灰色头像和默认的“微信用户”昵称<br>官方的解释是：实践中发现有部分小程序，在用户刚打开小程序时就要求收集用户的微信昵称头像，或者在支付前等不合理路径上要求授权。如果用户拒绝授权，则无法使用小程序或相关功能。在已经获取用户的 openId 与 unionId 信息情况下，用户的微信昵称与头像并不是用户使用小程序的必要条件。</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>我的解决方法是手动加一个权限弹窗</p>
<img src="/images/%E6%89%8B%E5%8A%A8%E5%BC%B9%E7%AA%97.gif" class="center" width="200" title="权限弹窗">

<h3 id="授权弹窗"><a href="#授权弹窗" class="headerlink" title="授权弹窗"></a>授权弹窗</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="title function_">signupAndLogin</span>(<span class="params"></span>) &#123;            <span class="comment">//bindtap事件</span></span><br><span class="line">    wx.<span class="title function_">showModal</span>(&#123;                     <span class="comment">//手动授权弹窗</span></span><br><span class="line">      <span class="attr">title</span>: <span class="string">&#x27;授权登录提示&#x27;</span>,</span><br><span class="line">      <span class="attr">content</span>: <span class="string">&#x27;是否允许授权？&#x27;</span>,</span><br><span class="line">      <span class="attr">showCancel</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">confirmText</span>: <span class="string">&#x27;允许&#x27;</span>,</span><br><span class="line">      <span class="attr">confirmColor</span>: <span class="string">&#x27;#669F76&#x27;</span>,</span><br><span class="line">      <span class="attr">cancelColor</span>: <span class="string">&#x27;#CC463D&#x27;</span>,</span><br><span class="line">      <span class="attr">success</span>: <span class="keyword">async</span> res =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (res.<span class="property">confirm</span>) &#123;     <span class="comment">//用户确认</span></span><br><span class="line">          <span class="keyword">const</span> &#123; <span class="attr">userInfo</span>: &#123; nickName, avatarUrl &#125; &#125; = <span class="keyword">await</span></span><br><span class="line">            wx.<span class="title function_">getUserProfile</span>(&#123;    <span class="comment">//获取用户信息，最新版本已不支持弹窗</span></span><br><span class="line">              <span class="attr">desc</span>: <span class="string">&#x27;用户授权&#x27;</span>,</span><br><span class="line">            &#125;)</span><br><span class="line"> </span><br><span class="line">          <span class="keyword">let</span> &#123; result &#125; = <span class="keyword">await</span> wx.<span class="property">cloud</span>.<span class="title function_">callFunction</span>(&#123;  <span class="comment">// 调用云函数</span></span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;loginOrSignup&#x27;</span>,</span><br><span class="line">            <span class="attr">data</span>: &#123;</span><br><span class="line">              nickName,</span><br><span class="line">              avatarUrl</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">          <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123; <span class="attr">userInfo</span>: result &#125;)</span><br><span class="line">          <span class="title function_">getApp</span>().<span class="property">globalData</span>.<span class="property">userStatus</span> = <span class="literal">true</span>   <span class="comment">//用于检查用户是否登录的全局变量</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (res.<span class="property">cancel</span>) &#123;     <span class="comment">//用户取消</span></span><br><span class="line">          wx.<span class="title function_">showToast</span>(&#123;</span><br><span class="line">            <span class="attr">title</span>: <span class="string">&#x27;取消授权&#x27;</span>,</span><br><span class="line">            <span class="attr">mask</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">icon</span>: <span class="string">&#x27;error&#x27;</span></span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h3 id="loginOrSignup云函数"><a href="#loginOrSignup云函数" class="headerlink" title="loginOrSignup云函数"></a>loginOrSignup云函数</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 云函数入口文件</span></span><br><span class="line"><span class="keyword">const</span> cloud = <span class="built_in">require</span>(<span class="string">&#x27;wx-server-sdk&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">cloud.<span class="title function_">init</span>(&#123; <span class="attr">env</span>: cloud.<span class="property">DYNAMIC_CURRENT_ENV</span> &#125;) <span class="comment">// 使用当前云环境</span></span><br><span class="line"><span class="keyword">const</span> db = cloud.<span class="title function_">database</span>()</span><br><span class="line"><span class="comment">// 云函数入口函数</span></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">main</span> = <span class="keyword">async</span> (event, context) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; <span class="variable constant_">OPENID</span> &#125; = cloud.<span class="title function_">getWXContext</span>()</span><br><span class="line">  <span class="keyword">const</span> &#123; nickName, avatarUrl &#125; = event</span><br><span class="line">  <span class="keyword">const</span> user_clct = db.<span class="title function_">collection</span>(<span class="string">&#x27;user&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">const</span> &#123; data &#125; = <span class="keyword">await</span> user_clct.<span class="title function_">where</span>(&#123;    <span class="comment">//查询用户是否存在</span></span><br><span class="line">    <span class="attr">_openId</span>: <span class="variable constant_">OPENID</span></span><br><span class="line">  &#125;).<span class="title function_">get</span>()</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (data.<span class="property">length</span> === <span class="number">0</span>) &#123;                     <span class="comment">//如果用户不存在，添加用户</span></span><br><span class="line">    <span class="keyword">let</span> user = <span class="keyword">await</span> user_clct.<span class="title function_">add</span>(&#123;</span><br><span class="line">      <span class="attr">data</span>: &#123;</span><br><span class="line">        nickName,</span><br><span class="line">        avatarUrl,</span><br><span class="line">        <span class="attr">_openId</span>: <span class="variable constant_">OPENID</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      nickName,</span><br><span class="line">      avatarUrl,</span><br><span class="line">      <span class="attr">_openId</span>: <span class="variable constant_">OPENID</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> data[<span class="number">0</span>]       <span class="comment">//如果用户存在，返回该用户信息</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="选择头像"><a href="#选择头像" class="headerlink" title="选择头像"></a>选择头像</h3><img src="/images/%E9%80%89%E6%8B%A9%E5%A4%B4%E5%83%8F.gif" class="center" width="200" title="权限弹窗">
<h1 id="-1"><a href="#-1" class="headerlink" title=""></a></h1><figure class="highlight html"><figcaption><span>wxml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;chooseAvatar&quot;</span> <span class="attr">open-type</span>=<span class="string">&quot;chooseAvatar&quot;</span> <span class="attr">bindchooseavatar</span>=<span class="string">&quot;chooseAvatar&quot;</span> <span class="attr">plain</span>=<span class="string">&quot;ture&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 160rpx; border: none;color: #6e6e6e;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">image</span> <span class="attr">class</span>=<span class="string">&quot;userAvatar&quot;</span> <span class="attr">src</span>=<span class="string">&quot;&#123;&#123;userInfo.avatarUrl&#125;&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="-2"><a href="#-2" class="headerlink" title=""></a></h1><figure class="highlight typescript"><figcaption><span>typescript</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="title function_">chooseAvatar</span>(<span class="params">e: <span class="built_in">any</span></span>) &#123;                <span class="comment">//用户更换头像</span></span><br><span class="line">    <span class="comment">//e.detail 已经是 avatarUrl：&quot;...&quot;的格式</span></span><br><span class="line">    <span class="keyword">let</span> &#123; avatarUrl &#125; = e.<span class="property">detail</span></span><br><span class="line"> </span><br><span class="line">    wx.<span class="property">cloud</span>.<span class="title function_">callFunction</span>(&#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;uploadAvatar&#x27;</span>,</span><br><span class="line">      <span class="attr">data</span>: &#123;</span><br><span class="line">        avatarUrl</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">success</span>: <span class="keyword">async</span> res =&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> &#123; result &#125; = <span class="keyword">await</span> wx.<span class="property">cloud</span>.<span class="title function_">callFunction</span>(&#123;  <span class="comment">// 调用登录云函数，不传参，用以更新页面中的用户信息</span></span><br><span class="line">          <span class="attr">name</span>: <span class="string">&#x27;loginOrSignup&#x27;</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123; <span class="attr">userInfo</span>: result &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<h3 id="uploadAvatar，更新头像"><a href="#uploadAvatar，更新头像" class="headerlink" title="uploadAvatar，更新头像"></a>uploadAvatar，更新头像</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 云函数入口文件</span></span><br><span class="line"><span class="keyword">const</span> cloud = <span class="built_in">require</span>(<span class="string">&#x27;wx-server-sdk&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">cloud.<span class="title function_">init</span>(&#123; <span class="attr">env</span>: cloud.<span class="property">DYNAMIC_CURRENT_ENV</span> &#125;) <span class="comment">// 使用当前云环境</span></span><br><span class="line"><span class="keyword">const</span> db = cloud.<span class="title function_">database</span>()</span><br><span class="line"><span class="comment">// 云函数入口函数</span></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">main</span> = <span class="keyword">async</span> (event, context) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; <span class="variable constant_">OPENID</span> &#125; = cloud.<span class="title function_">getWXContext</span>()</span><br><span class="line">  <span class="keyword">const</span> &#123; avatarUrl &#125; = event</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    db.<span class="title function_">collection</span>(<span class="string">&#x27;user&#x27;</span>).<span class="title function_">where</span>(&#123;</span><br><span class="line">      <span class="attr">_openId</span>: <span class="variable constant_">OPENID</span></span><br><span class="line">    &#125;).<span class="title function_">update</span>(&#123;</span><br><span class="line">      <span class="attr">data</span>: &#123;</span><br><span class="line">        avatarUrl</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">success</span>:<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> avatarUrl</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>篇1 DHCP</title>
    <url>/2023/07/09/%E7%BD%91%E7%BB%9C-Ensp/%E7%AF%871-DHCP/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>DHCP（Dynamic Host Configuration Protocol）是一个网络协议，用于自动分配IP地址和其他相关配置信息给网络设备。</p>
<p>在一个局域网中，DHCP服务器负责管理并分配IP地址给网络上的设备。当一台设备加入局域网或者需要更新自己的IP地址时，它会向DHCP服务器发送一个请求，并在服务器上进行IP地址分配。DHCP服务器收到请求后，会从预定义的IP地址池中选择一个可用的IP地址，并将其分配给设备。此外，DHCP服务器还可以为设备分配其他网络配置，如子网掩码、网关、DNS服务器等。</p>
<p>DHCP的优势在于它能够自动管理IP地址分配，简化了网络管理工作。通过使用DHCP，管理员可以集中管理IP地址的分配和配置，而无需手动为每个设备进行配置。DHCP还支持地址重用和动态更新配置，使得系统资源能够更有效地利用。</p>
<p>总而言之，DHCP是一个用于自动分配IP地址和相关配置信息的协议，它简化了网络管理工作，并提高了网络资源的利用效率。</p>
<h2 id="Ensp"><a href="#Ensp" class="headerlink" title="Ensp"></a>Ensp</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>AR2220路由器一台，S5700三层交换机一台，pc机若干</p>
<img src="/images/ensp-1.png" class="center" width="500">

<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li><p>输入 <code>sy</code> 进入路由系统视图，然后输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dhcp enable</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入路由器对应接口，开启接口DHCP服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">interface g0/0/0</span><br><span class="line"></span><br><span class="line">dhcp select interface</span><br></pre></td></tr></table></figure>
</li>
<li><p>pc机刷新dhcp配置即可</p>
</li>
</ol>
<h3 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;Huawei&gt;sy</span><br><span class="line"></span><br><span class="line">[Huawei]interface g0/0/0</span><br><span class="line"></span><br><span class="line">[Huawei-GigabitEthernet0/0/0]ip address 192.168.1.1 255.255.255.0</span><br><span class="line"></span><br><span class="line">[Huawei-GigabitEthernet0/0/0] quit</span><br><span class="line"></span><br><span class="line">[Huawei]dhcp enable </span><br><span class="line"></span><br><span class="line">[Huawei-GigabitEthernet0/0/0]dhcp select interface</span><br></pre></td></tr></table></figure>



<h3 id="检验"><a href="#检验" class="headerlink" title="检验"></a>检验</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">PC&gt;</span><span class="language-bash">ipconfig</span></span><br><span class="line"></span><br><span class="line">Link local IPv6 address...........: fe80::5689:98ff:feec:2846</span><br><span class="line">IPv6 address......................: :: / 128</span><br><span class="line">IPv6 gateway......................: ::</span><br><span class="line">IPv4 address......................: 192.168.1.254</span><br><span class="line">Subnet mask.......................: 255.255.255.0</span><br><span class="line">Gateway...........................: 192.168.1.1</span><br><span class="line">Physical address..................: 54-89-98-EC-28-46</span><br><span class="line">DNS server........................: 0.0.0.0</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>网络-Ensp</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器事件循环</title>
    <url>/2023/07/02/%E5%89%8D%E7%AB%AF/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</url>
    <content><![CDATA[<h2 id="事件循环的背景"><a href="#事件循环的背景" class="headerlink" title="事件循环的背景"></a>事件循环的背景</h2><h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><p>浏览器在运行中会开启很多进程，其中最主要的进程有：</p>
<ol>
<li>浏览器进程<br> 主要负责界面显示、用户交互、子进程管理等。浏览器进程内部又会启动多个线程处理不同的任务</li>
<li>网络进程<br> 负责加载网络资源。网络进程内容会启动多个线程来处理不同任务</li>
<li>渲染进程<br> 渲染进程启动后会开启一个<strong>渲染主线程</strong>，负责执行html、css、js代码。默认情况下，浏览器会为每一个标签页开启一个新的渲染进程，以保证不同的标签页之间互不影响</li>
</ol>
<h3 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h3><p>JS 是单线程的语言，这是因为它运行在浏览器的渲染主线程中，而渲染主线程只有一个，且承担诸多工作，如渲染页面、执行JS等，因此如果使用同步的方式，就很容易导致主线程产生阻塞，从而导致消息队列中的其他任务无法执行</p>
<p>所以浏览器采用异步的方式来避免。具体做法是当某些任务发生时，比如计时器、网络事件监听，主线程将任务交给其他线程去处理，转而执行后续代码。当其他线程完成时，将事先传递的回调函数包装成任务，加入到消息队列的末尾排队，等待主线程调度执行</p>
<p>在这中异步模式下，最大限度的保证了单线程的流程执行</p>
<p><u>因此单线程是异步产生的原因，事件循环是异步的实现方式</u></p>
<h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><p>事件循环也称消息循环，是浏览器渲染主线程的工作方式。</p>
<p>循环指的是在不同的消息队列中进行循环，每次循环从当前队列中取出第一个任务执行，其他线程只需要在合适的时候将任务加入到队列末尾即可</p>
<h3 id="队列优先级"><a href="#队列优先级" class="headerlink" title="队列优先级"></a>队列优先级</h3><ul>
<li>每个任务有不同的类型，同类型的任务必须在同一个队列，不同的任务可以处于不同的队列。不同的队列有不同的优先级，在一次事件循环中，有浏览器决定取哪一个队列的任务。</li>
<li>浏览器必须有一个微队列，微队列的任务一定具有最高的优先级，必须优先调度执行。</li>
</ul>
<p>目前包含以下队列：</p>
<ul>
<li>微队列：用户存放需要最快执行的任务，优先级最高</li>
<li>交互队列：用于存放用户操作后产生的事件处理任务，优先级高</li>
<li>延时队列：用于存放计时器到达后的回调任务，优先级中</li>
</ul>
<p>添加到微队列的方式主要是Promise、MutationObserver和async&#x2F;await<br>例如：</p>
<figure class="highlight javascript"><figcaption><span>Promise</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Done&#x27;</span>))</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><figcaption><span>MutationObserver</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建 MutationObserver 实例，并指定回调函数</span></span><br><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(<span class="function">(<span class="params">mutationsList, observer</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 处理 DOM 变化的逻辑</span></span><br><span class="line">  mutationsList.<span class="title function_">forEach</span>(<span class="function"><span class="params">mutation</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(mutation.<span class="property">type</span>); <span class="comment">// 打印变化的类型</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(mutation.<span class="property">target</span>); <span class="comment">// 打印发生变化的节点</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 observe 方法指定要监听的 DOM 元素和变化类型</span></span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>, &#123; <span class="attr">childList</span>: <span class="literal">true</span>, <span class="attr">subtree</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 停止监听 DOM 变化</span></span><br><span class="line">observer.<span class="title function_">disconnect</span>();</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><figcaption><span>async/await</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">//当调用 fetchData 函数时，它会立即返回一个 Promise 对象</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fetchData</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Start&#x27;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//await 表达式会在执行时创建一个微任务，并将其添加到微任务队列中,同时暂停主线程的执行。</span></span><br><span class="line">  <span class="comment">//这样可以确保 await 后面的代码在前面的异步操作完成后才会执行。</span></span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;https://api.example.com/data&#x27;</span>); </span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> result.<span class="title function_">json</span>();</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Data:&#x27;</span>, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Before&#x27;</span>);</span><br><span class="line"><span class="title function_">fetchData</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;After&#x27;</span>);</span><br><span class="line"></span><br><span class="line">最后结果：</span><br><span class="line"><span class="title class_">Before</span></span><br><span class="line"><span class="title class_">After</span></span><br><span class="line"><span class="title class_">Start</span></span><br><span class="line"><span class="title class_">Data</span>: &#123;&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序实现类似qq界面侧滑效果</title>
    <url>/2023/06/23/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%BC%BCqq%E7%95%8C%E9%9D%A2%E4%BE%A7%E6%BB%91%E6%95%88%E6%9E%9C/</url>
    <content><![CDATA[<h2 id="效果浏览"><a href="#效果浏览" class="headerlink" title="效果浏览"></a>效果浏览</h2><img src="/images/%E4%BE%A7%E6%BB%91%E7%95%8C%E9%9D%A2.gif" class="center" width="200" title="效果演示" alt="侧滑界面">

<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="wxml"><a href="#wxml" class="headerlink" title="wxml"></a>wxml</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;outBox&quot;</span> <span class="attr">bindtouchstart</span>=<span class="string">&quot;out_touchStart&quot;</span> <span class="attr">bindtouchmove</span>=<span class="string">&quot;out_touchMove&quot;</span> <span class="attr">bindtouchend</span>=<span class="string">&quot;out_touchEnd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">text</span> <span class="attr">style</span>=<span class="string">&quot;width: 100vw;text-align: center;&quot;</span>&gt;</span>主界面<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;sliderPage&quot;</span> <span class="attr">style</span>=<span class="string">&quot;transform:translateX(&#123;&#123;moveX&#125;&#125;);&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">text</span>&gt;</span>侧滑界面<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="wxss"><a href="#wxss" class="headerlink" title="wxss"></a>wxss</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.outBox</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100vh</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100vw</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.466</span>);</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="selector-class">.sliderPage</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100vh</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">80vw</span>;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.842</span>);</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">2px</span> <span class="number">0px</span> <span class="number">10px</span> <span class="number">0px</span> <span class="number">#00000038</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateX</span>(-<span class="number">80vw</span>);</span><br><span class="line">  <span class="attribute">transition</span>: <span class="number">0.2s</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ts"><a href="#ts" class="headerlink" title="ts"></a>ts</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Page</span>(&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 页面的初始数据</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">fullWidth</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">vw</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">moveX</span>: <span class="string">&#x27;-80vw&#x27;</span>,</span><br><span class="line">    <span class="attr">startX</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">sliderActive</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">watchMoveX</span>: <span class="number">0</span>,</span><br><span class="line">  &#125;,</span><br><span class="line"> </span><br><span class="line">  <span class="title function_">out_touchStart</span>(<span class="params">e: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> &#123; touches &#125; = e</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123; <span class="attr">startX</span>: touches[<span class="number">0</span>].<span class="property">clientX</span> &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line"> </span><br><span class="line">  <span class="title function_">out_touchMove</span>(<span class="params">e: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> &#123; touches &#125; = e</span><br><span class="line">    <span class="keyword">let</span> nowX = touches[<span class="number">0</span>].<span class="property">clientX</span></span><br><span class="line">    <span class="keyword">let</span> moveX = nowX - <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">startX</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">sliderActive</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (moveX &gt;= <span class="number">0</span> || moveX &lt; -(<span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">fullWidth</span> * <span class="number">0.8</span>)) <span class="keyword">return</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">        <span class="attr">moveX</span>: <span class="string">`<span class="subst">$&#123;moveX&#125;</span>px`</span>,</span><br><span class="line">        <span class="attr">watchMoveX</span>: moveX</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (moveX &lt;= <span class="number">0</span> || moveX &gt; (<span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">fullWidth</span> * <span class="number">0.8</span>)) <span class="keyword">return</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">        <span class="attr">moveX</span>: <span class="string">`<span class="subst">$&#123;-<span class="number">80</span> * <span class="variable language_">this</span>.data.vw + moveX&#125;</span>px`</span>,</span><br><span class="line">        <span class="attr">watchMoveX</span>: moveX</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"> </span><br><span class="line">  <span class="title function_">out_touchEnd</span>(<span class="params">e: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">sliderActive</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">watchMoveX</span> &gt; (<span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">fullWidth</span> / <span class="number">4</span>)) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">          <span class="attr">moveX</span>: <span class="string">`<span class="subst">$&#123;<span class="number">0</span>&#125;</span>vw`</span>,</span><br><span class="line">          <span class="attr">sliderActive</span>: <span class="literal">true</span>,</span><br><span class="line">          <span class="attr">watchMoveX</span>: <span class="number">0</span></span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123; <span class="attr">moveX</span>: <span class="string">`<span class="subst">$&#123;-<span class="number">80</span>&#125;</span>vw`</span> &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">watchMoveX</span> &lt; -(<span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">fullWidth</span> / <span class="number">4</span>)) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">          <span class="attr">moveX</span>: <span class="string">`<span class="subst">$&#123;-<span class="number">80</span>&#125;</span>vw`</span>,</span><br><span class="line">          <span class="attr">sliderActive</span>: <span class="literal">false</span>,</span><br><span class="line">          <span class="attr">watchMoveX</span>: <span class="number">0</span></span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123; <span class="attr">moveX</span>: <span class="string">&#x27;0vw&#x27;</span> &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// ------------------------------</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 生命周期函数--监听页面加载</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">onLoad</span>(<span class="params"></span>) &#123;</span><br><span class="line">    wx.<span class="title function_">createSelectorQuery</span>().<span class="title function_">select</span>(<span class="string">&quot;.outBox&quot;</span>).<span class="title function_">boundingClientRect</span>().<span class="title function_">exec</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">        <span class="attr">vw</span>: res[<span class="number">0</span>].<span class="property">width</span> / <span class="number">100</span>,</span><br><span class="line">        <span class="attr">fullWidth</span>: res[<span class="number">0</span>].<span class="property">width</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  ....<span class="comment">//省略其他周期函数</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>实现这种侧滑效果的方法有很多，这只是其中一种<br>两个界面是嵌套关系，因此可以只通过外部元素节点，也就是主界面的touch控制来实现滑动效果</p>
]]></content>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>篇10-ISIS+OSPF+BGP组合</title>
    <url>/2023/10/03/%E7%BD%91%E7%BB%9C-Ensp/%E7%AF%8710-ISIS-OSPF-BGP%E7%BB%84%E5%90%88/</url>
    <content><![CDATA[<p><img src="/../../images/%E5%AE%9E%E9%AA%8C/ISIS+OSPF+BGP.png"></p>
<h1 id="实验情景"><a href="#实验情景" class="headerlink" title="实验情景"></a>实验情景</h1><ul>
<li>蓝线区域使用IS-IS协议，其中，蓝色区域为Level-2</li>
<li>红色区域使用OSPF协议</li>
<li>上述二者使用BGP协议传输数据，用于模拟运营商传输网与企业网相连接</li>
</ul>
<h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><ol>
<li><p>ISIS与外部所连接的接口最好也启用ISIS，可以省去很多麻烦，如实验中AR1的g0&#x2F;0&#x2F;1口</p>
</li>
<li><p>使用BGP需要在两个自治系统（AS）中建立对等EBGP，那么这里就有一个很重要的问题：ISIS传输网到企业网时，使用BGP的到底是ISIS中的哪个路由？</p>
<p>询问了一些人，有的说与Level-1-2直连建立EBGP，这样在BGP中导入ISIS路由就可以了。但是这样Level-1不就显得多余吗？经过一番测试，我还想到与Level-1-2在Loopback上建立BGP关系，虽然这样物理上是经过了Level-1，但还是感觉有点多余。</p>
<p>后来突然想到<u>可以将Level-2的路由渗透到Level-1，然后再让Level-1与外部进行BGP关系建立</u>就行了</p>
</li>
<li><p>需要在ISIS协议中有BGP的路由，也需要在BGP中有ISIS的路由，还需要在OSPF中有BGP的路由以及BGP中有OSPF的路由。总的来说，就是<u>两个双向导入</u></p>
</li>
</ol>
<h1 id="操作记录及步骤"><a href="#操作记录及步骤" class="headerlink" title="操作记录及步骤"></a>操作记录及步骤</h1><ol>
<li><p>所有路由接口配上ip，如AR1的g0&#x2F;0&#x2F;0为10.1.12.1</p>
</li>
<li><p>配置好ISIS内部通信</p>
<ul>
<li><p>Level-1，以AR1为例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#</span><br><span class="line">isis 100</span><br><span class="line"> is-level level-1</span><br><span class="line"> network-entity 49.0002.0000.0000.0001.00</span><br><span class="line"> import-route bgp level-1                            //在level-1区域导入bgp的路由</span><br><span class="line">#</span><br></pre></td></tr></table></figure>
</li>
<li><p>Level-1-2，以AR2为例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#</span><br><span class="line">isis 100</span><br><span class="line"> network-entity 49.0002.0000.0000.0002.00</span><br><span class="line"> import-route isis level-2 into level-1              //将level-2路由渗透至level-1</span><br><span class="line">#</span><br></pre></td></tr></table></figure>
</li>
<li><p>Level-2，以AR5为例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#</span><br><span class="line">isis 100</span><br><span class="line"> is-level level-2</span><br><span class="line"> network-entity 49.0004.0000.0000.0005.00</span><br><span class="line">#</span><br></pre></td></tr></table></figure>
</li>
<li><p>做好以上配置还需在接口上启用ISIS</p>
</li>
</ul>
</li>
<li><p>配置好OSPF内部通信</p>
<ul>
<li><p>实验中只设一个区域，以AR8为例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#</span><br><span class="line">ospf 1 </span><br><span class="line"> import-route bgp                                       //导入BGP路由</span><br><span class="line"> area 0.0.0.0 </span><br><span class="line">  network 10.1.0.0 0.0.255.255 </span><br><span class="line">#</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>在两个系统边界配置EBGP，由于是直连，所以不用配置最大跳数</p>
<ul>
<li><p>AR1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#</span><br><span class="line">bgp 100</span><br><span class="line"> peer 10.1.18.8 as-number 800 </span><br><span class="line"> #</span><br><span class="line"> ipv4-family unicast</span><br><span class="line">  undo synchronization</span><br><span class="line">  import-route isis 100                                 //导入ISIS的路由</span><br><span class="line">  peer 10.1.18.8 enable</span><br><span class="line">#</span><br></pre></td></tr></table></figure>
</li>
<li><p>AR8：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#</span><br><span class="line">bgp 800</span><br><span class="line"> peer 10.1.18.1 as-number 100 </span><br><span class="line"> #</span><br><span class="line"> ipv4-family unicast</span><br><span class="line">  undo synchronization</span><br><span class="line">  import-route ospf 1                                   //导入OSPF路由</span><br><span class="line">  peer 10.1.18.1 enable</span><br><span class="line">#</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h1 id="检验"><a href="#检验" class="headerlink" title="检验"></a>检验</h1><p>在AR10中pingAR7</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;AR7&gt;ping 10.1.67.7</span><br><span class="line">  PING 10.1.67.7: 56  data bytes, press CTRL_C to break</span><br><span class="line">    Reply from 10.1.67.7: bytes=56 Sequence=1 ttl=249 time=70 ms</span><br><span class="line">    Reply from 10.1.67.7: bytes=56 Sequence=2 ttl=249 time=50 ms</span><br><span class="line">    Reply from 10.1.67.7: bytes=56 Sequence=3 ttl=249 time=70 ms</span><br><span class="line">    Reply from 10.1.67.7: bytes=56 Sequence=4 ttl=249 time=60 ms</span><br><span class="line">    Reply from 10.1.67.7: bytes=56 Sequence=5 ttl=249 time=70 ms</span><br><span class="line"></span><br><span class="line">  --- 10.1.67.7 ping statistics ---</span><br><span class="line">    5 packet(s) transmitted</span><br><span class="line">    5 packet(s) received</span><br><span class="line">    0.00% packet loss</span><br><span class="line">    round-trip min/avg/max = 50/64/70 ms</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>网络-Ensp</tag>
      </tags>
  </entry>
  <entry>
    <title>篇2 Dns 域名解析</title>
    <url>/2023/07/10/%E7%BD%91%E7%BB%9C-Ensp/%E7%AF%872-Dns%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>DNS（Domain Name System，域名系统）是互联网中用于将域名转换为对应IP地址的系统。它充当了互联网上的“电话簿”，将易于记忆的域名（如<a href="http://www.example.com)映射到对应的ip地址(如192.0.2.1)./">www.example.com）映射到对应的IP地址（如192.0.2.1）。</a></p>
<p>DNS的主要功能包括域名解析、域名注册和域名管理。 域名解析是DNS的核心功能，当用户在浏览器中输入一个域名时，DNS系统会将该域名解析为对应的IP地址，以便建立与目标服务器的连接。域名注册是指将一个域名注册到DNS系统中，以确保该域名在互联网上的唯一性。域名管理则涉及到对域名的配置、修改和管理，包括设置域名的DNS记录、子域名管理等。 </p>
<p>DNS采用分层的结构，由多个DNS服务器组成，分为根域名服务器、顶级域名服务器、权威域名服务器和本地域名服务器等。当本地域名服务器无法解析域名时，会向上级域名服务器查询，直到找到对应的IP地址。 </p>
<p>简单来说，<u>就是当用户访问某个域名时，会先在域名解析服务器上查找该域名对应的ip地址，找到后再访问该IP地址，用户可以使用易于记忆的域名来访问互联网上的各种资源，而无需记住复杂的IP地址。</u>同时，DNS还支持其他功能，如邮件服务器的查找、反向解析等。</p>
<h2 id="准备内容"><a href="#准备内容" class="headerlink" title="准备内容"></a>准备内容</h2><p>ar2220路由一台、server服务器一台、s5700三层交换机一台、pc机若干</p>
<img src="/images/ensp-%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90.png" class="center" width="500">


<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li>给服务器添加自身ip地址，在服务器中的dns解析服务添加域名列表，并启动服务</li>
<li>在路由对应接口输入<code>dhcp server dns-list [域名解析服务器ip]</code></li>
<li>pc机刷新dhcp配置</li>
</ol>
<h2 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h2><h3 id="添加域名"><a href="#添加域名" class="headerlink" title="添加域名"></a>添加域名</h3><img src="/images/dns%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%B7%BB%E5%8A%A0ip.png" class="center" width="500">


<img src="/images/ensp-dns%E6%9C%8D%E5%8A%A1%E5%99%A8.png" class="center" width="500">

<h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[Huawei]interface g0/0/0</span><br><span class="line">[Huawei-GigabitEthernet0/0/0]dhcp server dns-list 192.168.1.100</span><br></pre></td></tr></table></figure>



<h3 id="刷新并检验"><a href="#刷新并检验" class="headerlink" title="刷新并检验"></a>刷新并检验</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">PC&gt;</span><span class="language-bash">ipconfig</span></span><br><span class="line"></span><br><span class="line">Link local IPv6 address...........: fe80::5689:98ff:feec:2846</span><br><span class="line">IPv6 address......................: :: / 128</span><br><span class="line">IPv6 gateway......................: ::</span><br><span class="line">IPv4 address......................: 192.168.1.254</span><br><span class="line">Subnet mask.......................: 255.255.255.0</span><br><span class="line">Gateway...........................: 192.168.1.1</span><br><span class="line">Physical address..................: 54-89-98-EC-28-46</span><br><span class="line">DNS server........................: 192.168.1.100</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">PC&gt;</span><span class="language-bash">ping www.example.com</span></span><br><span class="line"></span><br><span class="line">Ping www.example.com [192.168.1.253]: 32 data bytes, Press Ctrl_C to break</span><br><span class="line">From 192.168.1.253: bytes=32 seq=1 ttl=128 time=47 ms</span><br><span class="line">From 192.168.1.253: bytes=32 seq=2 ttl=128 time=15 ms</span><br><span class="line">From 192.168.1.253: bytes=32 seq=3 ttl=128 time=47 ms</span><br><span class="line">From 192.168.1.253: bytes=32 seq=4 ttl=128 time=47 ms</span><br><span class="line">From 192.168.1.253: bytes=32 seq=5 ttl=128 time=31 ms</span><br><span class="line"></span><br><span class="line">--- 192.168.1.253 ping statistics ---</span><br><span class="line">  5 packet(s) transmitted</span><br><span class="line">  5 packet(s) received</span><br><span class="line">  0.00% packet loss</span><br><span class="line">  round-trip min/avg/max = 15/37/47 ms</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>网络-Ensp</tag>
      </tags>
  </entry>
  <entry>
    <title>篇3 网关</title>
    <url>/2023/07/10/%E7%BD%91%E7%BB%9C-Ensp/%E7%AF%873-%E7%BD%91%E5%85%B3/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>网关（Gateway）是在计算机网络中连接不同网络的设备或软件。它充当了网络中不同协议、不同网络体系结构之间的桥梁，负责转发数据包、协议转换和数据格式转换等功能。</p>
<p>网关可以连接不同类型的网络，如将局域网（LAN）连接到广域网（WAN），或将不同的协议（如TCP&#x2F;IP和IPX&#x2F;SPX）进行转换。<u>它可以是硬件设备，如路由器、交换机或防火墙，也可以是软件程序，如网络代理服务器或应用层网关。</u></p>
<p>网关在网络通信中扮演重要角色，它能够实现以下功能：</p>
<ol>
<li><p>数据包转发：网关接收来自源网络的数据包，并将其转发到目标网络上的正确目的地。</p>
</li>
<li><p>协议转换：网关可以将来自一个协议的数据包转换为另一个协议的数据包，以便不同类型的网络能够进行通信。</p>
</li>
<li><p>数据格式转换：网关可以将数据包的格式从一种形式转换为另一种形式，以便目标网络能够正确解析和处理数据。</p>
</li>
<li><p>安全性控制：网关可以实施安全策略，如防火墙功能，对网络流量进行过滤和检查，保护网络免受恶意攻击和未经授权的访问。</p>
</li>
</ol>
<p>总之，网关在网络中起到了连接不同网络、协议转换和数据转发等重要作用，使得不同网络能够互相通信和交换数据。</p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>在篇二的基础上增加一台pc4,与路由相连</p>
<img src="/images/%E7%BD%91%E5%85%B3%E5%AE%9E%E9%AA%8C%E5%87%86%E5%A4%87.png" class="center" width="500">




<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li>为路由与pc4相连端口添加ip</li>
<li>为pc1和pc4添加静态ip和网关</li>
</ol>
<h2 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h2><p>pc1</p>
<img src="/images/pc1%E8%AE%BE%E7%BD%AE%E7%BD%91%E5%85%B3.png" class="center" width="500">

<p>pc4</p>
<img src="/images/pc4%E8%AE%BE%E7%BD%AE%E7%BD%91%E5%85%B3.png" class="center" width="500">



<h2 id="检验"><a href="#检验" class="headerlink" title="检验"></a>检验</h2><p><strong>pc1 ping pc4</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">PC&gt;</span><span class="language-bash">ping 100.100.100.100</span></span><br><span class="line"></span><br><span class="line">Ping 100.100.100.100: 32 data bytes, Press Ctrl_C to break</span><br><span class="line">Request timeout!</span><br><span class="line">From 100.100.100.100: bytes=32 seq=2 ttl=127 time=47 ms</span><br><span class="line">From 100.100.100.100: bytes=32 seq=3 ttl=127 time=31 ms</span><br><span class="line">From 100.100.100.100: bytes=32 seq=4 ttl=127 time=32 ms</span><br><span class="line">From 100.100.100.100: bytes=32 seq=5 ttl=127 time=47 ms</span><br><span class="line"></span><br><span class="line">--- 100.100.100.100 ping statistics ---</span><br><span class="line">  5 packet(s) transmitted</span><br><span class="line">  4 packet(s) received</span><br><span class="line">  20.00% packet loss</span><br><span class="line">  round-trip min/avg/max = 0/39/47 ms</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>pc4 ping pc1</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">PC&gt;</span><span class="language-bash">ping 192.168.1.168</span></span><br><span class="line"></span><br><span class="line">Ping 192.168.1.168: 32 data bytes, Press Ctrl_C to break</span><br><span class="line">Request timeout!</span><br><span class="line">Request timeout!</span><br><span class="line">From 192.168.1.168: bytes=32 seq=3 ttl=127 time=32 ms</span><br><span class="line">From 192.168.1.168: bytes=32 seq=4 ttl=127 time=47 ms</span><br><span class="line">From 192.168.1.168: bytes=32 seq=5 ttl=127 time=47 ms</span><br><span class="line"></span><br><span class="line">--- 192.168.1.168 ping statistics ---</span><br><span class="line">  5 packet(s) transmitted</span><br><span class="line">  3 packet(s) received</span><br><span class="line">  40.00% packet loss</span><br><span class="line">  round-trip min/avg/max = 0/42/47 ms</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>pc4 访问篇二中的域名</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">PC&gt;</span><span class="language-bash">ping www.example.com</span></span><br><span class="line"></span><br><span class="line">Ping www.example.com [192.168.1.253]: 32 data bytes, Press Ctrl_C to break</span><br><span class="line">Request timeout!</span><br><span class="line">From 192.168.1.253: bytes=32 seq=2 ttl=127 time=31 ms</span><br><span class="line">From 192.168.1.253: bytes=32 seq=3 ttl=127 time=47 ms</span><br><span class="line">From 192.168.1.253: bytes=32 seq=4 ttl=127 time=31 ms</span><br><span class="line">From 192.168.1.253: bytes=32 seq=5 ttl=127 time=47 ms</span><br><span class="line"></span><br><span class="line">--- 192.168.1.253 ping statistics ---</span><br><span class="line">  5 packet(s) transmitted</span><br><span class="line">  4 packet(s) received</span><br><span class="line">  20.00% packet loss</span><br><span class="line">  round-trip min/avg/max = 0/39/47 ms</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>网络-Ensp</tag>
      </tags>
  </entry>
  <entry>
    <title>篇4 静态路由</title>
    <url>/2023/07/17/%E7%BD%91%E7%BB%9C-Ensp/%E7%AF%874-%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>静态路由是网络中使用静态路由表来确定数据包的传输路径的一种路由方式。它是通过手动配置路由器上的路由表来指定目标网络和下一跳路由器的关系，以确定数据包的传输路径。</p>
<p>在静态路由中，网络管理员手动配置路由器上的路由表，将目标网络的 IP 地址和对应的下一跳路由器的 IP 地址进行映射。当路由器收到一个数据包时，它会根据数据包的目标 IP 地址查找路由表，找到与目标 IP 地址匹配的条目，并将数据包发送到相应的下一跳路由器。下一跳路由器将继续根据路由表将数据包转发到下一个路由器，直到数据包到达目标网络。</p>
<p>静态路由的主要特点包括：</p>
<ol>
<li>静态路由是手动配置的，不会自动适应网络变化。如果网络拓扑发生变化，管理员需要手动更新路由表。</li>
<li>静态路由是固定的，不会根据网络负载或链路状态进行动态调整。所有数据包都将按照路由表中的配置进行转发。</li>
<li>静态路由的配置相对简单，适用于小型网络或网络拓扑不经常变化的情况。</li>
<li>静态路由的优点是稳定性高，因为路由表不会频繁变化，不会产生额外的路由协议开销。</li>
</ol>
<p>静态路由适用于简单的网络环境或需要精确控制数据包传输路径的情况。对于复杂的网络环境或需要自动适应网络变化的情况，通常会使用动态路由协议来实现路由功能。</p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>AR2220 路由两台、交换机一台、PC 机若干</p>
<img src="/images/%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1%E5%AE%9E%E9%AA%8C%E5%87%86%E5%A4%87.png" class="center" width="500">



<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>在路由上输入指令，告诉路由去往目的ip网段应该走的下一跳，<u>下一跳指的是下一个经过的路由的接口所对应的ip</u></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip route-static [目标ip（通常是网段）] [子网掩码] [下一跳ip]</span><br></pre></td></tr></table></figure>



<h2 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h2><h3 id="基础路由配置"><a href="#基础路由配置" class="headerlink" title="基础路由配置"></a>基础路由配置</h3><h4 id="第一台路由"><a href="#第一台路由" class="headerlink" title="第一台路由"></a>第一台路由</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[Huawei]interface GigabitEthernet 0/0/0</span><br><span class="line">[Huawei-GigabitEthernet0/0/0]ip address 192.168.1.1 255.255.255.0</span><br><span class="line"></span><br><span class="line">[Huawei]interface GigabitEthernet 0/0/1</span><br><span class="line">[Huawei-GigabitEthernet0/0/1]ip address 192.168.2.1 255.255.255.0</span><br></pre></td></tr></table></figure>

<h4 id="第二台"><a href="#第二台" class="headerlink" title="第二台"></a>第二台</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[Huawei]interface GigabitEthernet 0/0/0</span><br><span class="line">[Huawei-GigabitEthernet0/0/0]ip address 192.168.2.10 255.255.255.0</span><br><span class="line"></span><br><span class="line">[Huawei]interface GigabitEthernet 0/0/1</span><br><span class="line">[Huawei-GigabitEthernet0/0/0]ip address 192.168.3.1 255.255.255.0</span><br></pre></td></tr></table></figure>



<h3 id="配置静态路由"><a href="#配置静态路由" class="headerlink" title="配置静态路由"></a>配置静态路由</h3><h4 id="第一台"><a href="#第一台" class="headerlink" title="第一台"></a>第一台</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[Huawei]ip route-static 192.168.3.0 255.255.255.0 192.168.2.10</span><br></pre></td></tr></table></figure>

<h4 id="第二台-1"><a href="#第二台-1" class="headerlink" title="第二台"></a>第二台</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[Huawei]ip route-static 192.168.1.0 255.255.255.0 192.168.2.1</span><br></pre></td></tr></table></figure>



<h2 id="检验"><a href="#检验" class="headerlink" title="检验"></a>检验</h2><h3 id="pc1-ping-服务器和pc2"><a href="#pc1-ping-服务器和pc2" class="headerlink" title="pc1 ping 服务器和pc2"></a>pc1 ping 服务器和pc2</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">PC&gt;</span><span class="language-bash">ping 192.168.3.100</span></span><br><span class="line"></span><br><span class="line">Ping 192.168.3.100: 32 data bytes, Press Ctrl_C to break</span><br><span class="line">From 192.168.3.100: bytes=32 seq=1 ttl=126 time=47 ms</span><br><span class="line">From 192.168.3.100: bytes=32 seq=2 ttl=126 time=47 ms</span><br><span class="line">From 192.168.3.100: bytes=32 seq=3 ttl=126 time=47 ms</span><br><span class="line">From 192.168.3.100: bytes=32 seq=4 ttl=126 time=31 ms</span><br><span class="line">From 192.168.3.100: bytes=32 seq=5 ttl=126 time=63 ms</span><br><span class="line"></span><br><span class="line">--- 192.168.3.100 ping statistics ---</span><br><span class="line">  5 packet(s) transmitted</span><br><span class="line">  5 packet(s) received</span><br><span class="line">  0.00% packet loss</span><br><span class="line">  round-trip min/avg/max = 31/47/63 ms</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">PC&gt;</span><span class="language-bash">ping 192.168.3.10</span></span><br><span class="line"></span><br><span class="line">Ping 192.168.3.10: 32 data bytes, Press Ctrl_C to break</span><br><span class="line">From 192.168.3.10: bytes=32 seq=1 ttl=253 time=31 ms</span><br><span class="line">From 192.168.3.10: bytes=32 seq=2 ttl=253 time=32 ms</span><br><span class="line">From 192.168.3.10: bytes=32 seq=3 ttl=253 time=31 ms</span><br><span class="line">From 192.168.3.10: bytes=32 seq=4 ttl=253 time=31 ms</span><br><span class="line">From 192.168.3.10: bytes=32 seq=5 ttl=253 time=31 ms</span><br><span class="line"></span><br><span class="line">--- 192.168.3.10 ping statistics ---</span><br><span class="line">  5 packet(s) transmitted</span><br><span class="line">  5 packet(s) received</span><br><span class="line">  0.00% packet loss</span><br><span class="line">  round-trip min/avg/max = 31/31/32 ms</span><br></pre></td></tr></table></figure>

<h3 id="pc2-ping-pc1"><a href="#pc2-ping-pc1" class="headerlink" title="pc2 ping pc1"></a>pc2 ping pc1</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">PC&gt;</span><span class="language-bash">ping 192.168.1.10</span></span><br><span class="line"></span><br><span class="line">Ping 192.168.1.10: 32 data bytes, Press Ctrl_C to break</span><br><span class="line">Request timeout!</span><br><span class="line">From 192.168.1.10: bytes=32 seq=2 ttl=126 time=31 ms</span><br><span class="line">From 192.168.1.10: bytes=32 seq=3 ttl=126 time=31 ms</span><br><span class="line">From 192.168.1.10: bytes=32 seq=4 ttl=126 time=47 ms</span><br><span class="line">From 192.168.1.10: bytes=32 seq=5 ttl=126 time=16 ms</span><br><span class="line"></span><br><span class="line">--- 192.168.1.10 ping statistics ---</span><br><span class="line">  5 packet(s) transmitted</span><br><span class="line">  4 packet(s) received</span><br><span class="line">  20.00% packet loss</span><br><span class="line">  round-trip min/avg/max = 0/31/47 ms</span><br></pre></td></tr></table></figure>

<p>注：配置好静态路由后，首次ping操作出现timeout是正常的</p>
]]></content>
      <tags>
        <tag>网络-Ensp</tag>
      </tags>
  </entry>
  <entry>
    <title>篇5 vlan</title>
    <url>/2023/07/20/%E7%BD%91%E7%BB%9C-Ensp/%E7%AF%875-vlan/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>VLAN（Virtual Local Area Network）是一种虚拟局域网技术，用于将一个物理网络划分为多个逻辑上独立的虚拟网络。VLAN可以提供更好的网络管理和安全性。</p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><img src="/images/vlan%E5%87%86%E5%A4%87.png" class="center" width="500">

<p>三层交换机两台、pc机若干</p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li><p>创建vlan —— <code>vlan [vlan号]</code> </p>
</li>
<li><p>划分vlan：<br>  （1）进入接口<br>  （2）<code>port link-type access</code> （终端，如电脑、打印机等为access；其他交换机则为trunk）<br>  （3）<code>port default vlan [vlan号]</code></p>
</li>
<li><p>交换机之间允许vlan通信<br>  （1）进入接口<br>  （2）<code>port link-type trunk</code><br>  （3）<code>port trunk allow-pass vlan [vlan号]</code></p>
</li>
</ol>
<h2 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h2><ol>
<li><p>LSW1(第一台交换机)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;Huawei&gt;sy</span><br><span class="line">Enter system view, return user view with Ctrl+Z.</span><br><span class="line"></span><br><span class="line">//创建vlan</span><br><span class="line">[Huawei]vlan 10</span><br><span class="line">[Huawei-vlan10]q</span><br><span class="line">[Huawei]vlan 20</span><br><span class="line">[Huawei-vlan20]q</span><br><span class="line"></span><br><span class="line">//划分vlan</span><br><span class="line">[Huawei]interface GigabitEthernet 0/0/1</span><br><span class="line">[Huawei-GigabitEthernet0/0/1]port link-type access </span><br><span class="line">[Huawei-GigabitEthernet0/0/1]port default vlan 10</span><br><span class="line">[Huawei-GigabitEthernet0/0/1]q</span><br><span class="line"></span><br><span class="line">[Huawei]interface GigabitEthernet 0/0/2</span><br><span class="line">[Huawei-GigabitEthernet0/0/2]port link-type access 	</span><br><span class="line">[Huawei-GigabitEthernet0/0/2]port default vlan 20</span><br><span class="line">[Huawei-GigabitEthernet0/0/2]q</span><br><span class="line"></span><br><span class="line">[Huawei]interface GigabitEthernet 0/0/3</span><br><span class="line">[Huawei-GigabitEthernet0/0/3]port link-type access 	</span><br><span class="line">[Huawei-GigabitEthernet0/0/3]port default vlan 20</span><br><span class="line">[Huawei-GigabitEthernet0/0/3]q</span><br><span class="line"></span><br><span class="line">[Huawei]interface GigabitEthernet 0/0/4</span><br><span class="line">[Huawei-GigabitEthernet0/0/4]port link-type trunk</span><br><span class="line">[Huawei-GigabitEthernet0/0/4]port trunk allow-pass vlan 10</span><br><span class="line">[Huawei-GigabitEthernet0/0/4]port trunk allow-pass vlan 20</span><br></pre></td></tr></table></figure>


</li>
<li><p>LSW2(第二台交换机)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;Huawei&gt;sy</span><br><span class="line">Enter system view, return user view with Ctrl+Z.</span><br><span class="line"></span><br><span class="line">//创建vlan</span><br><span class="line">[Huawei]vlan 10</span><br><span class="line">[Huawei-vlan10]q</span><br><span class="line">[Huawei]vlan 20</span><br><span class="line">[Huawei-vlan20]q</span><br><span class="line"></span><br><span class="line">//划分vlan</span><br><span class="line">[Huawei]interface GigabitEthernet 0/0/1</span><br><span class="line">[Huawei-GigabitEthernet0/0/1]port link-type access </span><br><span class="line">[Huawei-GigabitEthernet0/0/1]port default vlan 10</span><br><span class="line">[Huawei-GigabitEthernet0/0/1]q</span><br><span class="line"></span><br><span class="line">[Huawei]interface GigabitEthernet 0/0/2</span><br><span class="line">[Huawei-GigabitEthernet0/0/2]port link-type access </span><br><span class="line">[Huawei-GigabitEthernet0/0/2]port default vlan 20</span><br><span class="line">[Huawei-GigabitEthernet0/0/2]q</span><br><span class="line"></span><br><span class="line">[Huawei]interface GigabitEthernet 0/0/3</span><br><span class="line">[Huawei-GigabitEthernet0/0/3]port link-type trunk </span><br><span class="line">[Huawei-GigabitEthernet0/0/3]port trunk allow-pass vlan 10</span><br><span class="line">[Huawei-GigabitEthernet0/0/3]port trunk allow-pass vlan 20</span><br></pre></td></tr></table></figure>


</li>
<li><p>给pc机的ip从左到右依次设为1.1.1.1~1.1.1.5</p>
</li>
</ol>
<h2 id="检验"><a href="#检验" class="headerlink" title="检验"></a>检验</h2><p><strong>pc1 ping pc2，由于不在同一个vlan中，ping操作失败</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">PC&gt;</span><span class="language-bash">ping 1.1.1.2</span></span><br><span class="line"></span><br><span class="line">Ping 1.1.1.2: 32 data bytes, Press Ctrl_C to break</span><br><span class="line">From 1.1.1.1: Destination host unreachable</span><br><span class="line">From 1.1.1.1: Destination host unreachable</span><br><span class="line">From 1.1.1.1: Destination host unreachable</span><br><span class="line">From 1.1.1.1: Destination host unreachable</span><br><span class="line">From 1.1.1.1: Destination host unreachable</span><br><span class="line"></span><br><span class="line">--- 1.1.1.2 ping statistics ---</span><br><span class="line">  5 packet(s) transmitted</span><br><span class="line">  0 packet(s) received</span><br><span class="line">  100.00% packet loss</span><br></pre></td></tr></table></figure>

<p><strong>同样的，pc2 ping pc1 也是失败</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">PC&gt;</span><span class="language-bash">ping 1.1.1.1</span></span><br><span class="line"></span><br><span class="line">Ping 1.1.1.1: 32 data bytes, Press Ctrl_C to break</span><br><span class="line">From 1.1.1.2: Destination host unreachable</span><br><span class="line">From 1.1.1.2: Destination host unreachable</span><br><span class="line">From 1.1.1.2: Destination host unreachable</span><br><span class="line">From 1.1.1.2: Destination host unreachable</span><br><span class="line">From 1.1.1.2: Destination host unreachable</span><br><span class="line"></span><br><span class="line">--- 1.1.1.1 ping statistics ---</span><br><span class="line">  5 packet(s) transmitted</span><br><span class="line">  0 packet(s) received</span><br><span class="line">  100.00% packet loss</span><br></pre></td></tr></table></figure>

<p><strong>pc1 与 pc5 互ping也是失败</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//pc1 ping pc5</span><br><span class="line"><span class="meta prompt_">PC&gt;</span><span class="language-bash">ping 1.1.1.5</span></span><br><span class="line"></span><br><span class="line">Ping 1.1.1.5: 32 data bytes, Press Ctrl_C to break</span><br><span class="line">From 1.1.1.1: Destination host unreachable</span><br><span class="line">From 1.1.1.1: Destination host unreachable</span><br><span class="line">From 1.1.1.1: Destination host unreachable</span><br><span class="line">From 1.1.1.1: Destination host unreachable</span><br><span class="line">From 1.1.1.1: Destination host unreachable</span><br><span class="line"></span><br><span class="line">--- 1.1.1.5 ping statistics ---</span><br><span class="line">  5 packet(s) transmitted</span><br><span class="line">  0 packet(s) received</span><br><span class="line">  100.00% packet loss</span><br><span class="line">  </span><br><span class="line">//pc5 ping pc1</span><br><span class="line"><span class="meta prompt_">PC&gt;</span><span class="language-bash">ping 1.1.1.1</span></span><br><span class="line"></span><br><span class="line">Ping 1.1.1.1: 32 data bytes, Press Ctrl_C to break</span><br><span class="line">From 1.1.1.5: Destination host unreachable</span><br><span class="line">From 1.1.1.5: Destination host unreachable</span><br><span class="line">From 1.1.1.5: Destination host unreachable</span><br><span class="line">From 1.1.1.5: Destination host unreachable</span><br><span class="line">From 1.1.1.5: Destination host unreachable</span><br><span class="line"></span><br><span class="line">--- 1.1.1.1 ping statistics ---</span><br><span class="line">  5 packet(s) transmitted</span><br><span class="line">  0 packet(s) received</span><br><span class="line">  100.00% packet loss</span><br></pre></td></tr></table></figure>



<p><strong>相同vlan下互ping不影响</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//pc1 ping pc4</span><br><span class="line"><span class="meta prompt_">PC&gt;</span><span class="language-bash">ping 1.1.1.4</span></span><br><span class="line"></span><br><span class="line">Ping 1.1.1.4: 32 data bytes, Press Ctrl_C to break</span><br><span class="line">From 1.1.1.4: bytes=32 seq=1 ttl=128 time=47 ms</span><br><span class="line">From 1.1.1.4: bytes=32 seq=2 ttl=128 time=78 ms</span><br><span class="line">From 1.1.1.4: bytes=32 seq=3 ttl=128 time=78 ms</span><br><span class="line">From 1.1.1.4: bytes=32 seq=4 ttl=128 time=79 ms</span><br><span class="line">From 1.1.1.4: bytes=32 seq=5 ttl=128 time=63 ms</span><br><span class="line"></span><br><span class="line">--- 1.1.1.4 ping statistics ---</span><br><span class="line">  5 packet(s) transmitted</span><br><span class="line">  5 packet(s) received</span><br><span class="line">  0.00% packet loss</span><br><span class="line">  round-trip min/avg/max = 47/69/79 ms</span><br><span class="line">  </span><br><span class="line">//pc4 ping pc1</span><br><span class="line"><span class="meta prompt_">PC&gt;</span><span class="language-bash">ping 1.1.1.1</span></span><br><span class="line"></span><br><span class="line">Ping 1.1.1.1: 32 data bytes, Press Ctrl_C to break</span><br><span class="line">From 1.1.1.1: bytes=32 seq=1 ttl=128 time=63 ms</span><br><span class="line">From 1.1.1.1: bytes=32 seq=2 ttl=128 time=62 ms</span><br><span class="line">From 1.1.1.1: bytes=32 seq=3 ttl=128 time=78 ms</span><br><span class="line">From 1.1.1.1: bytes=32 seq=4 ttl=128 time=62 ms</span><br><span class="line">From 1.1.1.1: bytes=32 seq=5 ttl=128 time=63 ms</span><br><span class="line"></span><br><span class="line">--- 1.1.1.1 ping statistics ---</span><br><span class="line">  5 packet(s) transmitted</span><br><span class="line">  5 packet(s) received</span><br><span class="line">  0.00% packet loss</span><br><span class="line">  round-trip min/avg/max = 62/65/78 ms</span><br><span class="line">  </span><br><span class="line">//pc2 ping pc5</span><br><span class="line"><span class="meta prompt_">PC&gt;</span><span class="language-bash">ping 1.1.1.5</span></span><br><span class="line"></span><br><span class="line">Ping 1.1.1.5: 32 data bytes, Press Ctrl_C to break</span><br><span class="line">From 1.1.1.5: bytes=32 seq=1 ttl=128 time=94 ms</span><br><span class="line">From 1.1.1.5: bytes=32 seq=2 ttl=128 time=78 ms</span><br><span class="line">From 1.1.1.5: bytes=32 seq=3 ttl=128 time=79 ms</span><br><span class="line">From 1.1.1.5: bytes=32 seq=4 ttl=128 time=78 ms</span><br><span class="line">From 1.1.1.5: bytes=32 seq=5 ttl=128 time=78 ms</span><br><span class="line"></span><br><span class="line">--- 1.1.1.5 ping statistics ---</span><br><span class="line">  5 packet(s) transmitted</span><br><span class="line">  5 packet(s) received</span><br><span class="line">  0.00% packet loss</span><br><span class="line">  round-trip min/avg/max = 78/81/94 ms</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>网络-Ensp</tag>
      </tags>
  </entry>
  <entry>
    <title>篇6 三层交换技术</title>
    <url>/2023/07/21/%E7%BD%91%E7%BB%9C-Ensp/%E7%AF%876-%E4%B8%89%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>三层交换技术是指将网络交换机与路由器的功能结合起来，使交换机能够进行基于网络层（第三层）的转发和路由功能。它在传统二层交换机的基础上增加了路由功能，从而能够更高效地处理大规模网络中的数据流量和转发需求。</p>
<p>三层交换技术的主要特点如下：</p>
<ol>
<li>路由能力：<u>三层交换机具备路由器的基本功能，能够在不同的子网之间进行数据包的转发和路由决策</u>。它能够识别目标IP地址，并根据路由表进行转发决策，使数据能够跨越不同的子网进行传输。</li>
<li>VLAN支持：三层交换机支持虚拟局域网（VLAN）技术，可以将物理网络划分为多个逻辑上独立的虚拟网络。通过VLAN的配置，可以实现更好的网络隔离和安全性。</li>
<li>高性能转发：三层交换机采用硬件加速和快速转发技术，能够高效处理数据包的路由和转发。它可以进行流量控制、负载均衡和快速转发等功能，以提供更快的数据传输速度和更高的性能。</li>
<li>动态路由协议支持：三层交换机一般支持主要的动态路由协议，如OSPF、BGP和RIP等，能够与其他路由器进行动态路由协议的交互和学习，以实现更智能的网络路径选择和故障恢复能力。</li>
</ol>
<p>通过三层交换技术，可以在较大的网络中实现更高效、可靠和有灵活性的数据转发和路由功能，并提供更好的网络性能和管理能力。这对于大型企业、数据中心和服务提供商等具有重要意义。</p>
<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p>交换机两台（其中不与pc相连的交换机必须为三层交换机）、pc若干</p>
<img src="/images/%E4%B8%89%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%8A%80%E6%9C%AF%E5%AE%9E%E9%AA%8C%E5%87%86%E5%A4%87.png" class="center" width="500">



<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><ol>
<li>近端交换机为两台pc划分不同的vlan，并为vlan放行</li>
<li>在远端交换机的逻辑接口上添加两台pc的网关ip，即远端交换机在此处起到了网关的作用</li>
</ol>
<h1 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h1><ol>
<li><p>近端交换机划分vlan，并放行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[Huawei]vlan batch 10 20</span><br><span class="line">[Huawei]int g0/0/1</span><br><span class="line">[Huawei-GigabitEthernet0/0/1]port link-type access 	</span><br><span class="line">[Huawei-GigabitEthernet0/0/1]port de vlan 10</span><br><span class="line">[Huawei-GigabitEthernet0/0/1]int g0/0/2</span><br><span class="line">[Huawei-GigabitEthernet0/0/2]port link-type access</span><br><span class="line">[Huawei-GigabitEthernet0/0/2]port de vlan 20</span><br><span class="line">[Huawei-GigabitEthernet0/0/2]int g0/0/3</span><br><span class="line">[Huawei-GigabitEthernet0/0/3]port link-type trunk </span><br><span class="line">[Huawei-GigabitEthernet0/0/3]port trunk allow-pass vlan all </span><br></pre></td></tr></table></figure>
</li>
<li><p>远端交换机配置vlan，并在vlan逻辑接口添加ip</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[Huawei]int g0/0/1</span><br><span class="line">[Huawei-GigabitEthernet0/0/1]port link-type trunk //此处居然不用放行</span><br><span class="line">[Huawei-GigabitEthernet0/0/1]q</span><br><span class="line">[Huawei]int Vlanif 10</span><br><span class="line">[Huawei-Vlanif10]ip address 1.1.1.1 255.255.255.0</span><br><span class="line">[Huawei-Vlanif10]int Vlanif 20</span><br><span class="line">[Huawei-Vlanif20]ip address 2.2.2.1 255.255.255.0</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="检验"><a href="#检验" class="headerlink" title="检验"></a>检验</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">PC&gt;</span><span class="language-bash">ping 1.1.1.254</span></span><br><span class="line"></span><br><span class="line">Ping 1.1.1.254: 32 data bytes, Press Ctrl_C to break</span><br><span class="line">From 1.1.1.254: bytes=32 seq=1 ttl=127 time=109 ms</span><br><span class="line">From 1.1.1.254: bytes=32 seq=2 ttl=127 time=63 ms</span><br><span class="line">From 1.1.1.254: bytes=32 seq=3 ttl=127 time=93 ms</span><br><span class="line">From 1.1.1.254: bytes=32 seq=4 ttl=127 time=94 ms</span><br><span class="line">From 1.1.1.254: bytes=32 seq=5 ttl=127 time=78 ms</span><br><span class="line"></span><br><span class="line">--- 1.1.1.254 ping statistics ---</span><br><span class="line">  5 packet(s) transmitted</span><br><span class="line">  5 packet(s) received</span><br><span class="line">  0.00% packet loss</span><br><span class="line">  round-trip min/avg/max = 63/87/109 ms</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">PC&gt;</span><span class="language-bash">ping 2.2.2.254</span></span><br><span class="line"></span><br><span class="line">Ping 2.2.2.254: 32 data bytes, Press Ctrl_C to break</span><br><span class="line">From 2.2.2.254: bytes=32 seq=1 ttl=127 time=156 ms</span><br><span class="line">From 2.2.2.254: bytes=32 seq=2 ttl=127 time=94 ms</span><br><span class="line">From 2.2.2.254: bytes=32 seq=3 ttl=127 time=78 ms</span><br><span class="line">From 2.2.2.254: bytes=32 seq=4 ttl=127 time=62 ms</span><br><span class="line">From 2.2.2.254: bytes=32 seq=5 ttl=127 time=94 ms</span><br><span class="line"></span><br><span class="line">--- 2.2.2.254 ping statistics ---</span><br><span class="line">  5 packet(s) transmitted</span><br><span class="line">  5 packet(s) received</span><br><span class="line">  0.00% packet loss</span><br><span class="line">  round-trip min/avg/max = 62/96/156 ms</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>网络-Ensp</tag>
      </tags>
  </entry>
  <entry>
    <title>篇9 NAT地址转换</title>
    <url>/2023/07/30/%E7%BD%91%E7%BB%9C-Ensp/%E7%AF%879-NAT%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>NAT（Network Address Translation，网络地址转换）是一种网络技术，用于在不同网络之间转换 IP 地址。它主要用于解决 IPv4 地址不足的问题，并提供了一种将私有 IP 地址转换为公共 IP 地址的方法。</p>
<p>NAT 地址转换有以下几种常见的类型：</p>
<ul>
<li>静态 NAT：静态 NAT 是一种一对一的地址转换方式，将一个私有 IP 地址映射到一个公共 IP 地址。这种方式通常用于将特定的内部服务器（如 Web 服务器或邮件服务器）暴露给外部网络。 </li>
<li>动态 NAT：动态 NAT 是一种多对一的地址转换方式，将多个私有 IP 地址映射到一个或多个公共 IP 地址。这种方式通常用于将内部网络中的多个主机共享一个公共 IP 地址。 </li>
<li>PAT（Port Address Translation）：PAT 是一种多对一的地址转换方式，将多个私有 IP 地址映射到一个公共 IP 地址，并使用不同的端口号来区分不同的连接。这种方式通常用于家庭或小型办公室网络，以实现多个主机共享一个公共 IP 地址。</li>
</ul>
<p>NAT 地址转换的工作原理如下：</p>
<ol>
<li>内部主机发送数据包到外部网络时，源 IP 地址会被转换为 NAT 设备的公共 IP 地址。</li>
<li>NAT 设备会在转换表中记录转换的信息，以便在响应数据包返回时将目标 IP 地址转换回相应的内部 IP 地址。</li>
<li>外部网络返回的数据包到达 NAT 设备时，目标 IP 地址会被转换为相应的内部 IP 地址，并将数据包转发给内部主机。 NAT 地址转换提供了一种有效的方式来扩展 IPv4 地址空间，并实现内部网络与外部网络之间的通信。它在家庭网络、企业网络和互联网服务提供商等场景中广泛应用。</li>
</ol>
<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p><img src="/../../images/NAT%E5%AE%9E%E9%AA%8C%E5%87%86%E5%A4%87.png"></p>
<h1 id="情景一"><a href="#情景一" class="headerlink" title="情景一"></a>情景一</h1><p><strong>pc2 可以ping通10.1.12.2，不能ping通10.1.12.1</strong></p>
<ul>
<li>原因：</li>
</ul>
<p>​     1. pc2 与 AR2 直连，AR1 内部有10.1.12.0和2.2.2.0网段的路由，pc1向10.1.12.2发送的数据包能够得到回应，所以可以ping通</p>
<p>​     2. AR2 与 AR1 直连，pc2 ping 10.1.12.1 时，发送数据包时是没问题的，10.1.12.1可以接收到数据包，但是<u><strong>AR1没有2.2.2.0 网段的路由</strong></u>，所以得不到回应，请求超时。</p>
<ul>
<li>解决方法：</li>
</ul>
<p>​     1. 直接给AR2添加私网的路由，但这样做就将私网ip暴露在了公网，相当于私网ip成了公网ip，而公网ip资源珍贵</p>
<p>​     2. 使用NAT地址转换，将私网ip转化成公网ip，私网向外发送的数据包就携带了公网ip，这样就能得到回应</p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li>定义需要转换的ip（使用acl定义源ip）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Huawei]acl name 【acl name】 basic</span><br><span class="line">Huawei-acl-basic-aclname]rule permit source 【源ip段】【源ip反码】</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>定义要转换成的ip（使用nat定义ip组）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Huawei]nat address-group 【地址组号】【地址区间头】【地址区间尾】</span><br><span class="line">如：</span><br><span class="line">[Huawei]nat address-group 1 192.168.1.0 192.168.2.0</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在对外接口上应用规则</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Huawei-GigabitEthernet0/0/1]nat outbound 【acl编号】 address-group 【地址组号】</span><br><span class="line">如：</span><br><span class="line">[Huawei-GigabitEthernet0/0/1]nat outbound 2999 address-group 1</span><br></pre></td></tr></table></figure>



<h1 id="情景二"><a href="#情景二" class="headerlink" title="情景二"></a>情景二</h1><p>服务器server1需要向外提供访问服务，但是直接添加私有ip的路由安全性太低</p>
<p>解决方法：使用静态NAT地址转换让服务器向外提供固定公网ip进行访问</p>
<h2 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h2><p>进入出口路由<u><strong>对外接口</strong></u></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nat server global 【NAT ip】 inside 【原ip】</span><br></pre></td></tr></table></figure>

<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>动态nat转换，内网中的设备数量是不确定的，同一时间会使用nat ip组中的某一ip向外访问，因此<u>外部是访问不到转换后的nat ip的</u>，但是如果路由表存在原来ip的路由，则<u><strong>仍然可以访问原来的IP</strong></u>（即转换前的IP）</p>
<p>以上步骤在转换ip时，要查看转换成的最终ip是否在其他路由设备的路由表上，否则会访问失败</p>
<h1 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h1><ul>
<li>在<strong>AR2</strong>为 2.2.2.0 网段添加动态NAT</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Huawei]acl name pc2 basic </span><br><span class="line">[Huawei-acl-basic-pc2]rule permit source 2.2.2.0 0.0.0.255    //定义要进行转换的ip</span><br><span class="line">[Huawei-acl-basic-pc2]q</span><br><span class="line"></span><br><span class="line">[Huawei]nat address-group 1 10.1.12.100 10.1.12.110       //定义转换后的IP，两个路由器存在该网段，														 //无需另外添加路由</span><br><span class="line"></span><br><span class="line">[Huawei-GigabitEthernet0/0/1]nat outbound 2999 address-group 1     //在对外接口应用，进行绑定</span><br><span class="line">//因为是将内部设备出去访问的ip进行转换，所以是outbond</span><br><span class="line"></span><br><span class="line">[Huawei-GigabitEthernet0/0/0]nat ?                     //华为设备动态nat好像只能outbound</span><br><span class="line">  outbound  Specify net address translation</span><br><span class="line">  server    Specify NAT server</span><br><span class="line">  static    Specify static NAT</span><br></pre></td></tr></table></figure>

<ul>
<li>为PC3 添加 静态NAT</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Huawei]int g0/0/1</span><br><span class="line">[Huawei-GigabitEthernet0/0/1]nat server global 10.1.12.200 inside 3.3.3.3  //两个路由器已存在该网段路																	  //由，无需另外添加</span><br><span class="line">[Huawei-GigabitEthernet0/0/1]q                                    </span><br></pre></td></tr></table></figure>

<h1 id="检验"><a href="#检验" class="headerlink" title="检验"></a>检验</h1><ul>
<li>pc2 ping 10.1.12.1</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PC2&gt;ping 10.1.12.1</span><br><span class="line"></span><br><span class="line">Ping 10.1.12.1: 32 data bytes, Press Ctrl_C to break</span><br><span class="line">From 10.1.12.1: bytes=32 seq=1 ttl=254 time=16 ms</span><br><span class="line">From 10.1.12.1: bytes=32 seq=2 ttl=254 time=15 ms</span><br><span class="line">From 10.1.12.1: bytes=32 seq=3 ttl=254 time=16 ms</span><br><span class="line">From 10.1.12.1: bytes=32 seq=4 ttl=254 time=31 ms</span><br><span class="line">From 10.1.12.1: bytes=32 seq=5 ttl=254 time=16 ms</span><br><span class="line"></span><br><span class="line">--- 10.1.12.1 ping statistics ---</span><br><span class="line">  5 packet(s) transmitted</span><br><span class="line">  5 packet(s) received</span><br><span class="line">  0.00% packet loss</span><br><span class="line">  round-trip min/avg/max = 15/18/31 ms</span><br></pre></td></tr></table></figure>

<ul>
<li>PC2 ping PC1（在AR2路由器添加了1.1.1.0网段路由）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PC2&gt;ping 1.1.1.1 </span><br><span class="line"></span><br><span class="line">Ping 1.1.1.1: 32 data bytes, Press Ctrl_C to break</span><br><span class="line">Request timeout!</span><br><span class="line">From 1.1.1.1: bytes=32 seq=2 ttl=126 time=16 ms</span><br><span class="line">From 1.1.1.1: bytes=32 seq=3 ttl=126 time=15 ms</span><br><span class="line">From 1.1.1.1: bytes=32 seq=4 ttl=126 time=16 ms</span><br><span class="line">From 1.1.1.1: bytes=32 seq=5 ttl=126 time=15 ms</span><br><span class="line"></span><br><span class="line">--- 1.1.1.1 ping statistics ---</span><br><span class="line">  5 packet(s) transmitted</span><br><span class="line">  4 packet(s) received</span><br><span class="line">  20.00% packet loss</span><br><span class="line">  round-trip min/avg/max = 0/15/16 ms</span><br></pre></td></tr></table></figure>

<p>在PC1抓包，可以看到源ip地址已经变成了 10.1.12.103</p>
<p><img src="/../../images/NAT%E6%8A%93%E5%8C%85.png"></p>
<ul>
<li>由于pc3的nat的地址是静态的，所以 pc1 可以访问 PC3</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PC1&gt;ping 10.1.12.200</span><br><span class="line"></span><br><span class="line">Ping 10.1.12.200: 32 data bytes, Press Ctrl_C to break</span><br><span class="line">Request timeout!</span><br><span class="line">Request timeout!</span><br><span class="line">From 10.1.12.200: bytes=32 seq=3 ttl=126 time=16 ms</span><br><span class="line">From 10.1.12.200: bytes=32 seq=4 ttl=126 time=31 ms</span><br><span class="line">From 10.1.12.200: bytes=32 seq=5 ttl=126 time=15 ms</span><br><span class="line"></span><br><span class="line">--- 10.1.12.200 ping statistics ---</span><br><span class="line">  5 packet(s) transmitted</span><br><span class="line">  3 packet(s) received</span><br><span class="line">  40.00% packet loss</span><br><span class="line">  round-trip min/avg/max = 0/20/31 ms</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>网络-Ensp</tag>
      </tags>
  </entry>
  <entry>
    <title>篇7 单臂路由</title>
    <url>/2023/07/21/%E7%BD%91%E7%BB%9C-Ensp/%E7%AF%877-%E5%8D%95%E8%87%82%E8%B7%AF%E7%94%B1/</url>
    <content><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="单臂路由"><a href="#单臂路由" class="headerlink" title="单臂路由"></a>单臂路由</h2><p>单臂路由（One-Arm Routing）是一种特定的网络部署架构，其中路由器通过一个接口与源网络相连，并通过同一个接口与目标网络相连。在这种架构中，单个物理接口用于连接不同的网络，并处理流量的转发和路由。</p>
<p>常见的场景是将单臂路由用于网络地址转换（NAT）或实施访问控制列表（ACL）。使用单臂路由，可以将所有流量引导到路由器上，然后根据配置的规则和策略，将流量转发到目标网络或执行其他操作。这种部署方式可以在较小的网络环境中实现较灵活的流量控制和转发。</p>
<p>单臂路由在某些情况下会带来一些问题，例如可能导致网络拥塞、延迟增加以及安全性降低。因此，在部署单臂路由时需要考虑网络负载、带宽需求以及安全性需求等方面的因素。</p>
<h2 id="子接口终结"><a href="#子接口终结" class="headerlink" title="子接口终结"></a>子接口终结</h2><p>子接口终结（Subinterface Termination）是一种在路由器或三层交换机上实现虚拟接口的方法，用于实现不同VLAN之间的互联和通信。它允许将单个物理接口划分为多个逻辑接口，每个逻辑接口都与一个特定的VLAN相关联。</p>
<p>在以太网中，每个接口通常只能属于一个VLAN。但是，通过使用子接口终结技术，可以将单个物理接口划分为多个逻辑接口，每个逻辑接口都可以属于不同的VLAN。这样，可以在单个物理接口上同时传输和处理来自不同VLAN的数据。</p>
<p>子接口终结通常与802.1Q VLAN标记一起使用。每个子接口都与一个特定的VLAN ID相关联，并且可以配置相应的IP地址和子网掩码。通过这种方式，不同VLAN之间的通信可以通过路由器或三层交换机上的子接口进行转发。</p>
<p>子接口终结的概念在虚拟局域网（VLAN）的划分和互联中起着重要的作用。它提供了一种灵活的方式来管理和隔离不同的网络流量，并实现不同VLAN之间的通信。子接口终结还可以用于实现虚拟专用网（VPN）和其他网络隔离和分割的需求。</p>
<p>在ensp上<code>dot1q termination vid 10</code>命令用于在交换机上配置VLAN 10的802.1Q标记终结（termination）功能。当交换机接收到带有802.1Q VLAN标记的数据帧时，该命令会将数据帧从标记中解析出VLAN ID，并将数据帧发送到相应的VLAN。</p>
<p>具体而言，<code>dot1q termination vid 10</code>命令的作用如下：</p>
<ol>
<li><u>使交换机能够识别和处理带有802.1Q VLAN标记的数据帧。</u></li>
<li><u>将接收到的带有VLAN 10的数据帧发送到VLAN 10，以便在VLAN 10内进行交换和转发。</u></li>
<li><u>允许交换机与其他支持802.1Q VLAN标记的设备进行互联和通信。</u></li>
</ol>
<h2 id="arp"><a href="#arp" class="headerlink" title="arp"></a>arp</h2><p>ARP（Address Resolution Protocol）是一种用于将IP地址解析为MAC地址的网络协议。它在局域网中起到了重要的作用，帮助主机在通信过程中确定目标主机的物理地址。</p>
<p>在TCP&#x2F;IP协议中，每个主机都有一个唯一的IP地址用于网络通信。然而，在以太网等物理网络中，通信需要通过MAC地址来实现。因此，当主机需要与目标主机通信时，它需要知道目标主机的MAC地址。</p>
<p>这时候就需要使用ARP协议来进行地址解析。主机通过广播一个ARP请求消息来询问网络中的其他主机，询问某个IP地址对应的MAC地址。其他主机收到该请求后，如果它们拥有该IP地址，就会回复一个ARP响应消息，告知请求主机对应的MAC地址。</p>
<p>ARP协议的工作过程大致如下：</p>
<ol>
<li>主机A需要与主机B通信，但只知道主机B的IP地址，不知道MAC地址。</li>
<li>主机A发送一个ARP请求广播消息，询问网络中是否有主机B的MAC地址。</li>
<li>其他主机收到ARP请求后，检查自己的IP地址是否与请求中的目标IP地址相匹配。</li>
<li>如果有主机的IP地址与目标IP地址匹配，它会发送一个ARP响应消息，告知主机A自己的MAC地址。</li>
<li>主机A收到ARP响应后，就知道了主机B的MAC地址，可以使用该地址进行通信。</li>
</ol>
<p>一旦主机A获得了主机B的MAC地址，它就可以将数据包封装成以太网帧，并通过物理网络发送给主机B。这样，ARP协议帮助主机在通信过程中建立了IP地址与MAC地址之间的映射关系，实现了有效的网络通信。</p>
<h2 id="什么情况下需要开启arp"><a href="#什么情况下需要开启arp" class="headerlink" title="什么情况下需要开启arp"></a>什么情况下需要开启arp</h2><p>在常规情况下，路由器不需要开启 ARP（地址解析协议），因为路由器主要用于转发数据包，而不直接与主机通信。ARP主要用于在同一局域网中解析 IP 地址与 MAC 地址的对应关系。</p>
<p>然而，在某些特殊情况下，路由器可能需要开启 ARP。以下是一些可能需要开启 ARP 的情况：</p>
<ol>
<li>路由器作为局域网的默认网关：当路由器作为局域网中主机的默认网关时，它需要能够解析其他主机的 IP 地址与 MAC 地址的对应关系，以便正确转发数据包。</li>
<li>路由器与主机之间进行管理或配置：在某些情况下，网络管理员可能需要直接与路由器进行管理或配置，这时候路由器需要能够与主机进行通信，以便进行相关操作。</li>
<li>路由器上存在虚拟接口或子接口：在一些特殊的网络配置中，路由器可能会创建虚拟接口或子接口，这些接口需要能够与主机进行通信，以便进行特定的功能或服务。</li>
</ol>
<p>需要注意的是，开启 ARP 可能会增加网络的安全风险，因为 ARP 是一个基于广播的协议，可能会导致 ARP 欺骗攻击。因此，在开启 ARP 时，需要采取相应的安全措施，如使用 ARP 防护功能或限制 ARP 请求的范围。</p>
<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><img src="/images/%E5%8D%95%E8%87%82%E8%B7%AF%E7%94%B1%E5%AE%9E%E9%AA%8C%E5%87%86%E5%A4%87.png" class="" width="500">

<p>交换机一台，AR2220路由器一台，pc若干</p>
<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><ol>
<li>交换机配置vlan、划分vlan、放行vlan</li>
<li>路由配置vlan、子接口终结vlan、子接口开启arp广播、子接口添加网关ip</li>
</ol>
<h1 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h1><h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[Huawei]vlan batch 10 20</span><br><span class="line">[Huawei]int g0/0/1</span><br><span class="line">[Huawei-GigabitEthernet0/0/1]port link-type access </span><br><span class="line">[Huawei-GigabitEthernet0/0/1]port default vlan 10</span><br><span class="line">[Huawei-GigabitEthernet0/0/1]int g0/0/2</span><br><span class="line">[Huawei-GigabitEthernet0/0/2]port link-type access</span><br><span class="line">[Huawei-GigabitEthernet0/0/2]port default vlan 20</span><br><span class="line">[Huawei-GigabitEthernet0/0/2]int g0/0/3</span><br><span class="line">[Huawei-GigabitEthernet0/0/3]port link-type trunk </span><br><span class="line">[Huawei-GigabitEthernet0/0/3]port trunk allow-pass vlan all</span><br></pre></td></tr></table></figure>



<h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[Huawei]vlan batch 10 20</span><br><span class="line">Info: This operation may take a few seconds. Please wait for a moment...done.</span><br><span class="line">[Huawei]int g0/0/0.10</span><br><span class="line">[Huawei-GigabitEthernet0/0/0.10]dot1q termination vid 10</span><br><span class="line">[Huawei-GigabitEthernet0/0/0.10]arp broadcast enable </span><br><span class="line">[Huawei-GigabitEthernet0/0/0.10]ip address 1.1.1.1 255.255.255.0</span><br><span class="line"></span><br><span class="line">[Huawei-GigabitEthernet0/0/0.10]int g0/0/0.20</span><br><span class="line">[Huawei-GigabitEthernet0/0/0.20]dot1q termination vid 20</span><br><span class="line">[Huawei-GigabitEthernet0/0/0.20]arp broadcast enable</span><br><span class="line">[Huawei-GigabitEthernet0/0/0.20]ip address 2.2.2.1 255.255.255.0</span><br><span class="line">Jul 23 2023 00:08:01-08:00 Huawei %%01IFNET/4/LINK_STATE(l)[3]:The line protocol</span><br><span class="line"> IP on the interface GigabitEthernet0/0/0.20 has entered the UP state. </span><br></pre></td></tr></table></figure>



<h1 id="检验"><a href="#检验" class="headerlink" title="检验"></a>检验</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">PC1&gt;</span><span class="language-bash">ping 2.2.2.254</span></span><br><span class="line"></span><br><span class="line">Ping 2.2.2.254: 32 data bytes, Press Ctrl_C to break</span><br><span class="line">Request timeout!</span><br><span class="line">Request timeout!</span><br><span class="line">From 2.2.2.254: bytes=32 seq=3 ttl=127 time=78 ms</span><br><span class="line">From 2.2.2.254: bytes=32 seq=4 ttl=127 time=78 ms</span><br><span class="line">From 2.2.2.254: bytes=32 seq=5 ttl=127 time=79 ms</span><br><span class="line"></span><br><span class="line">--- 2.2.2.254 ping statistics ---</span><br><span class="line">  5 packet(s) transmitted</span><br><span class="line">  3 packet(s) received</span><br><span class="line">  40.00% packet loss</span><br><span class="line">  round-trip min/avg/max = 0/78/79 ms</span><br><span class="line"></span><br><span class="line">------------------------分界线--------------------------------------</span><br><span class="line"><span class="meta prompt_">PC2&gt;</span><span class="language-bash">ping 1.1.1.254</span></span><br><span class="line"></span><br><span class="line">Ping 1.1.1.254: 32 data bytes, Press Ctrl_C to break</span><br><span class="line">Request timeout!</span><br><span class="line">From 1.1.1.254: bytes=32 seq=2 ttl=127 time=78 ms</span><br><span class="line">From 1.1.1.254: bytes=32 seq=3 ttl=127 time=78 ms</span><br><span class="line">From 1.1.1.254: bytes=32 seq=4 ttl=127 time=63 ms</span><br><span class="line">From 1.1.1.254: bytes=32 seq=5 ttl=127 time=78 ms</span><br><span class="line"></span><br><span class="line">--- 1.1.1.254 ping statistics ---</span><br><span class="line">  5 packet(s) transmitted</span><br><span class="line">  4 packet(s) received</span><br><span class="line">  20.00% packet loss</span><br><span class="line">  round-trip min/avg/max = 0/74/78 ms</span><br><span class="line">  </span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line">//此时pc4和pc1、pc2没有了vlan隔离</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">PC4&gt;</span><span class="language-bash">ping 1.1.1.254</span></span><br><span class="line"></span><br><span class="line">Ping 1.1.1.254: 32 data bytes, Press Ctrl_C to break</span><br><span class="line">Request timeout!</span><br><span class="line">From 1.1.1.254: bytes=32 seq=2 ttl=127 time=47 ms</span><br><span class="line">From 1.1.1.254: bytes=32 seq=3 ttl=127 time=16 ms</span><br><span class="line">From 1.1.1.254: bytes=32 seq=4 ttl=127 time=31 ms</span><br><span class="line">From 1.1.1.254: bytes=32 seq=5 ttl=127 time=62 ms</span><br><span class="line"></span><br><span class="line">--- 1.1.1.254 ping statistics ---</span><br><span class="line">  5 packet(s) transmitted</span><br><span class="line">  4 packet(s) received</span><br><span class="line">  20.00% packet loss</span><br><span class="line">  round-trip min/avg/max = 0/39/62 ms</span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_">PC1&gt;</span><span class="language-bash">ping 3.3.3.254</span></span><br><span class="line"></span><br><span class="line">Ping 3.3.3.254: 32 data bytes, Press Ctrl_C to break</span><br><span class="line">Request timeout!</span><br><span class="line">From 3.3.3.254: bytes=32 seq=2 ttl=127 time=47 ms</span><br><span class="line">From 3.3.3.254: bytes=32 seq=3 ttl=127 time=31 ms</span><br><span class="line">From 3.3.3.254: bytes=32 seq=4 ttl=127 time=31 ms</span><br><span class="line">From 3.3.3.254: bytes=32 seq=5 ttl=127 time=31 ms</span><br><span class="line"></span><br><span class="line">--- 3.3.3.254 ping statistics ---</span><br><span class="line">  5 packet(s) transmitted</span><br><span class="line">  4 packet(s) received</span><br><span class="line">  20.00% packet loss</span><br><span class="line">  round-trip min/avg/max = 0/35/47 ms</span><br></pre></td></tr></table></figure>



<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>问题来了，这么做的意义是什么？</p>
<p>不使用vlan，将pc1、pc2的IP设置为同一网段不也可以进行通信吗？</p>
<p>这样做的目的就是<u>隔离了有可能出现的网络故障，但是保障了设备之间的通信</u></p>
]]></content>
      <tags>
        <tag>网络-Ensp</tag>
      </tags>
  </entry>
  <entry>
    <title>篇8 acl访问控制</title>
    <url>/2023/07/27/%E7%BD%91%E7%BB%9C-Ensp/%E7%AF%878-acl%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>ACL（Access Control List）是一种用于控制网络流量访问权限的机制。它可以根据预定义的规则来允许或拒绝特定类型的流量通过网络设备。</p>
<p>ACL 可以应用于路由器、交换机、防火墙等网络设备上的接口，以实现对网络流量的过滤和控制。它可以基于源 IP 地址、目标 IP 地址、协议类型、端口号等条件来决定是否允许流量通过。</p>
<p>通过配置 ACL，你可以实现以下功能：</p>
<ol>
<li>流量过滤：ACL 可以根据规则来过滤特定类型的流量，例如，只允许特定 IP 地址范围的流量通过，或者只允许特定协议和端口的流量通过。</li>
<li>访问控制：ACL 可以控制特定用户或设备对网络资源的访问权限。例如，你可以配置 ACL 来限制某些用户或设备只能访问特定的服务器或服务。</li>
<li>安全增强：ACL 可以帮助提高网络的安全性。通过拒绝不必要的流量或限制特定类型的流量，ACL 可以减少网络攻击的风险。</li>
</ol>
<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p><img src="/../../images/acl%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%AE%9E%E9%AA%8C%E5%87%86%E5%A4%87.png"></p>
<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><ol>
<li>创建acl</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Huawei]acl name 【aclName】 ?</span><br><span class="line">  INTEGER&lt;2000-2999&gt;  Basic access-list(add to current using rules)</span><br><span class="line">  INTEGER&lt;3000-3999&gt;  Advanced access-list(add to current using rules)</span><br><span class="line">  INTEGER&lt;4000-4999&gt;  Specify a L2 acl group</span><br><span class="line">  advance             Advanced acl                             //高级配置</span><br><span class="line">  basic               Basic acl								   //普通配置</span><br><span class="line">  link                Link acl</span><br><span class="line">  match-order         Set ACL&#x27;s match order</span><br><span class="line">  &lt;cr&gt;                Please press ENTER to execute command </span><br></pre></td></tr></table></figure>

<ol start="2">
<li>定义rule</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Huawei-acl-adv-test]rule ?</span><br><span class="line">  INTEGER&lt;0-4294967294&gt;  ID of ACL rule</span><br><span class="line">  deny                   Specify matched packet deny            //拒绝</span><br><span class="line">  permit                 Specify matched packet permit			//允许</span><br><span class="line">  </span><br><span class="line"> 如果是advance需要定义源ip和目的ip，以及声明基于协议类型，如：</span><br><span class="line"> rule deny ip source 【源ip（可以是网段）】 【子网掩码的反码】 destination 【目的ip（可以是网段）】 【子网掩码反码】</span><br><span class="line"> </span><br><span class="line"> 如果是basic则不需要定义目的ip和声明协议类型，如</span><br><span class="line"> rule deny source 123.123.0.0 0.0.255.255 </span><br></pre></td></tr></table></figure>

<ol start="3">
<li>应用acl</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">traffic-filter outbound acl name 【acl名称】                      //接口出方向</span><br><span class="line">traffic-filter inbound acl name 【acl名称】                       //接口入方向</span><br></pre></td></tr></table></figure>

<p><img src="/../../images/acl%E6%B5%81%E9%87%8F%E5%87%BA%E5%85%A5%E6%96%B9%E5%90%91.png"></p>
<h1 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h1><p>只拒绝pc1到10段的流量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Huawei]acl name test advance</span><br><span class="line">[Huawei-acl-adv-test]rule deny ip source 192.168.255.254 0.0.0.0 destination 10.0.0.0 0.255.255.255</span><br><span class="line">[Huawei-acl-adv-test]q</span><br><span class="line">[Huawei-GigabitEthernet0/0/0]traffic-filter inbound acl name test </span><br><span class="line">//也可以是：</span><br><span class="line">//[Huawei-GigabitEthernet0/0/1]traffic-filter outbound acl name test </span><br></pre></td></tr></table></figure>

<h1 id="检验"><a href="#检验" class="headerlink" title="检验"></a>检验</h1><ul>
<li>pc1 ping pc3 不通</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PC&gt;ping 10.0.0.254</span><br><span class="line"></span><br><span class="line">Ping 10.0.0.254: 32 data bytes, Press Ctrl_C to <span class="built_in">break</span></span><br><span class="line">Request <span class="built_in">timeout</span>!</span><br><span class="line">Request <span class="built_in">timeout</span>!</span><br><span class="line">Request <span class="built_in">timeout</span>!</span><br><span class="line">Request <span class="built_in">timeout</span>!</span><br><span class="line">Request <span class="built_in">timeout</span>!</span><br><span class="line"></span><br><span class="line">--- 10.0.0.254 ping statistics ---</span><br><span class="line">  5 packet(s) transmitted</span><br><span class="line">  0 packet(s) received</span><br><span class="line">  100.00% packet loss</span><br></pre></td></tr></table></figure>

<ul>
<li>pc3 ping pc1 也不通，因为访问是双向的</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PC&gt;ping 192.168.255.254</span><br><span class="line"></span><br><span class="line">Ping 192.168.255.254: 32 data bytes, Press Ctrl_C to <span class="built_in">break</span></span><br><span class="line">Request <span class="built_in">timeout</span>!</span><br><span class="line">Request <span class="built_in">timeout</span>!</span><br><span class="line">Request <span class="built_in">timeout</span>!</span><br><span class="line">Request <span class="built_in">timeout</span>!</span><br><span class="line">Request <span class="built_in">timeout</span>!</span><br><span class="line"></span><br><span class="line">--- 192.168.255.254 ping statistics ---</span><br><span class="line">  5 packet(s) transmitted</span><br><span class="line">  0 packet(s) received</span><br><span class="line">  100.00% packet loss</span><br></pre></td></tr></table></figure>

<ul>
<li>pc2 ping pc3 不影响</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PC&gt;ping 10.0.0.254</span><br><span class="line"></span><br><span class="line">Ping 10.0.0.254: 32 data bytes, Press Ctrl_C to <span class="built_in">break</span></span><br><span class="line">Request <span class="built_in">timeout</span>!</span><br><span class="line">From 10.0.0.254: bytes=32 <span class="built_in">seq</span>=2 ttl=127 time=31 ms</span><br><span class="line">From 10.0.0.254: bytes=32 <span class="built_in">seq</span>=3 ttl=127 time=32 ms</span><br><span class="line">From 10.0.0.254: bytes=32 <span class="built_in">seq</span>=4 ttl=127 time=31 ms</span><br><span class="line">From 10.0.0.254: bytes=32 <span class="built_in">seq</span>=5 ttl=127 time=31 ms</span><br><span class="line"></span><br><span class="line">--- 10.0.0.254 ping statistics ---</span><br><span class="line">  5 packet(s) transmitted</span><br><span class="line">  4 packet(s) received</span><br><span class="line">  20.00% packet loss</span><br><span class="line">  round-trip min/avg/max = 0/31/32 ms</span><br></pre></td></tr></table></figure>

<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>在定义规则的时候，一定要弄清楚源ip和目的ip，搞清楚流量方向</p>
<p>例如，如果acl规则是 </p>
<ol>
<li>拒绝<u><strong>源自 192.168 段到 10 段</strong></u>，则应该是在<strong>0口的入方向</strong>绑定或<strong>1口的出方向</strong>绑定，即：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Huawei-acl-adv-test]rule deny ip source 192.168.0.0 0.0.255.255 destination 10.0.0.0 0.255.255.255</span><br><span class="line"></span><br><span class="line">[Huawei-GigabitEthernet0/0/0]traffic-filter inbound acl name test    //0口入</span><br><span class="line">[Huawei-GigabitEthernet0/0/1]traffic-filter outbound acl name test   //1口出</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>拒绝<u><strong>源自 10 段到 192.168 段</strong></u>，则是在<strong>0口的出方向</strong>绑定或<strong>1口的入方向</strong>绑定，即：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Huawei-acl-adv-test]rule deny ip source 10.0.0.0 0.255.255.255 destination 192.168.0.0 0.0.255.255</span><br><span class="line"></span><br><span class="line">[Huawei-GigabitEthernet0/0/0]traffic-filter outbound acl name test    //0口出</span><br><span class="line">[Huawei-GigabitEthernet0/0/1]traffic-filter inbound acl name test     //1口入</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>网络-Ensp</tag>
      </tags>
  </entry>
  <entry>
    <title>篇外（1）光纤接入技术与PON</title>
    <url>/2023/07/27/%E7%BD%91%E7%BB%9C-Ensp/%E7%AF%87%E5%A4%96%EF%BC%881%EF%BC%89%E5%85%89%E7%BA%A4%E6%8E%A5%E5%85%A5%E6%8A%80%E6%9C%AF%E4%B8%8EPON/</url>
    <content><![CDATA[<h1 id="FTTX"><a href="#FTTX" class="headerlink" title="FTTX"></a>FTTX</h1><p>光纤接入网络（Fiber to the x，简称FTTx）是一种使用光纤作为传输介质的接入网络技术，用于提供高速宽带接入和传输服务。它将光纤延伸到用户的终端，取代了传统的铜线接入方式，提供更高的带宽和更稳定的连接。</p>
<p>光纤接入网络可以分为多种形式，包括：</p>
<ol>
<li><p>光纤到户（Fiber to the Home，简称FTTH）：将光纤延伸到用户家庭，提供高速宽带接入和传输服务。在FTTH中，光纤从中心办公室或分布节点延伸到用户家庭，通过光网络单元（ONU）将光信号转换为电信号，供用户使用。</p>
</li>
<li><p>光纤到楼（Fiber to the Building，简称FTTB）：将光纤延伸到多户建筑物，例如公寓楼或商业大厦。在FTTB中，光纤从中心办公室或分布节点延伸到建筑物内部，通过光网络单元（ONU）将光信号转换为电信号，供建筑物内的多个用户使用。</p>
</li>
<li><p>光纤到街（Fiber to the Curb，简称FTTC）：将光纤延伸到街道或小区的路边，然后使用传统的铜线将信号传输到用户家庭。在FTTC中，光纤从中心办公室或分布节点延伸到街道或小区的路边，通过光网络单元（ONU）将光信号转换为电信号，然后使用铜线将信号传输到用户家庭。</p>
</li>
<li><p>光纤到节点（Fiber To The Node，简称FTTN）：将光纤延伸到距离用户家庭较近的节点，然后使用传统的铜线将信号传输到用户家庭。这种方式相比FTTC，光纤延伸的距离更短，带宽和速度也更高。</p>
</li>
</ol>
<p>光纤接入网络具有高带宽、长距离传输、低干扰和低损耗的优势，可以满足日益增长的宽带需求。它为用户提供了更快速、可靠的互联网接入，支持高清视频、在线游戏、云存储和其他高带宽应用。光纤接入网络是未来通信网络发展的趋势，已经在许多地区得到广泛应用。</p>
<h1 id="PON"><a href="#PON" class="headerlink" title="PON"></a>PON</h1><p>无源光网络（Passive Optical Network，简称PON）是一种光纤传输技术，它采用被动光纤分配器（Passive Optical Splitter）来实现光信号的分配和传输，而不需要使用主动光电转换设备。无源光网络通常用于光纤接入网络（FTTx）中，用于提供高速宽带接入和传输服务。</p>
<ul>
<li>无源光网络的关键特点包括：</li>
</ul>
<ol>
<li><p>被动光纤分配器：无源光网络使用被动光纤分配器来将光信号分发给多个终端用户。被动光纤分配器是一种 pass-through 设备，不需要电力供应或主动调节，因此具有较低的成本、较小的体积和较高的可靠性。</p>
</li>
<li><p>点对多点拓扑结构：无源光网络采用点对多点的拓扑结构，其中一根光纤主干线连接到光线路终端（OLT），通过被动光纤分配器将信号分发给多个终端用户的光网络单元（ONU）。</p>
</li>
<li><p>共享带宽：在无源光网络中，多个终端用户共享同一根光纤主干线的带宽。通过使用时间分割多路访问（Time Division Multiplexing，简称TDM）或波分复用（Wavelength Division Multiplexing，简称WDM）技术，不同的终端用户可以在不同的时间或不同的波长上进行通信，实现带宽的共享。</p>
</li>
</ol>
<p>无源光网络具有高带宽、长距离传输、低成本和低功耗的优势，因此被广泛应用于光纤接入网络中，例如光纤到户（FTTH）、光纤到楼（FTTB）等场景，以提供高速宽带接入和传输服务。</p>
<ul>
<li>PON由以下几个主要组件组成：</li>
</ul>
<ol>
<li><p>OLT（Optical Line Terminal，光线路终端）：OLT是PON的核心设备，位于网络的中央，负责管理和控制整个PON网络。它连接到上层网络，如光纤骨干网或其他网络设备，并向下连接到ODN（Optical Distribution Network，光分布网络）。</p>
</li>
<li><p>ODN（Optical Distribution Network，光分布网络）：ODN是PON中的光纤分发网络，负责将光信号从OLT分发到多个用户的ONT（Optical Network Terminal，光网络终端）。ODN包括光纤、光纤连接器、光纤分纤器等设备，用于传输和分发光信号。</p>
</li>
<li><p>ONT（Optical Network Terminal，光网络终端）：ONT是用户侧的终端设备，负责接收、解析和处理从ODN传输过来的光信号，并将其转换为电信号。ONT通常具有以太网接口，可以连接到用户设备，如计算机、电话、路由器等，实现用户对光纤网络的接入和使用。</p>
</li>
<li><p>光纤：光纤是PON中传输光信号的媒介，用于连接OLT、ODN和ONT。它具有高带宽、低损耗和抗干扰等特性，能够实现高速、稳定的光信号传输。</p>
</li>
<li><p>光纤连接器：光纤连接器用于连接光纤，确保光信号的传输质量和连接的可靠性。常见的光纤连接器类型包括SC、LC、FC等。</p>
</li>
<li><p>光纤分纤器：光纤分纤器用于将光信号从OLT分发到多个用户的ONT。它可以将光信号分成多个光路，以实现光信号的分发和共享。</p>
</li>
</ol>
<p>综上所述，PON由OLT、ODN、ONT、光纤、光纤连接器和光纤分纤器等组件组成，通过这些组件实现光信号的传输、分发和接入。</p>
<img src="/images/PON.jpg" class="" width="850" title="PON结构图">

<h1 id="OLT"><a href="#OLT" class="headerlink" title="OLT"></a>OLT</h1><p>OLT（Optical Line Terminal）是光纤通信系统中的一种设备，用于光纤接入网的传输和交换。</p>
<p>OLT通常安装在光纤接入网的核心节点，作为光纤通信系统的主干设备。它连接光纤馈线和用户接入设备，负责将光信号转换为电信号，并将数据传输到用户终端。</p>
<p>OLT的主要功能包括：</p>
<ol>
<li><p>光信号转换：OLT接收来自光纤馈线的光信号，并将其转换为电信号进行处理和传输。</p>
</li>
<li><p>数据交换：OLT具有交换功能，可以根据用户的需求和网络拓扑结构，将数据从一个接口转发到另一个接口。</p>
</li>
<li><p>用户管理：OLT可以管理和控制连接到光纤接入网的用户设备，包括分配IP地址、认证用户身份、配置网络参数等。</p>
</li>
<li><p>安全管理：OLT可以实施安全策略，保护光纤接入网的数据安全和网络安全。</p>
</li>
<li><p>故障检测和排除：OLT可以监测光纤接入网的状态和性能，及时发现故障并进行排除。</p>
</li>
</ol>
<p>OLT通常具有高容量和高速率的特点，可以支持大量用户的接入需求，并提供高速、稳定的光纤接入服务。在光纤通信系统中，OLT与用户设备之间的连接通常使用以太网协议，如EPON（Ethernet Passive Optical Network）或GPON（Gigabit Passive Optical Network）。</p>
<p>总之，OLT是光纤通信系统中的关键设备，起到光纤接入网的传输、交换和管理的作用，是实现高速、稳定光纤接入服务的重要组成部分。</p>
<h1 id="ODN"><a href="#ODN" class="headerlink" title="ODN"></a>ODN</h1><p>ODN是光分布网络（Optical Distribution Network）的缩写，也称为光纤分布网络。它是光纤通信系统中的一部分，用于将光信号从光线路终端（OLT）传输到终端用户的光网络单元（ONU）。</p>
<p><u>ODN主要由光纤、光分纤盒、光分纤线和光分纤配线架等组成</u>。光纤是传输光信号的介质，光分纤盒是用于连接和保护光纤的装置，光分纤线是连接光纤盒和ONU的线缆，光分纤配线架是用于管理和组织光纤的架构。</p>
<p>在光纤接入网络中，ODN起到了将光信号从光线路终端传输到终端用户的作用。光信号从光线路终端经过光纤传输到光分纤盒，然后通过光分纤线连接到终端用户的ONU。ODN提供了高效、可靠的光信号传输和分发，使得终端用户可以享受到高速宽带接入和传输服务。</p>
<p>ODN的设计和布局需要考虑光纤的传输损耗、光分纤盒的连接和保护、光分纤线的布线和连接、光分纤配线架的管理和组织等因素。合理的ODN设计可以提高光信号的传输质量和可靠性，确保光纤接入网络的正常运行和服务质量。</p>
<h1 id="ONT"><a href="#ONT" class="headerlink" title="ONT"></a>ONT</h1><p>ONT（Optical Network Terminal）是光纤通信系统中的一种设备，也称为光网终端或光纤猫（Optical Network Terminal）。它是光纤接入网中用户侧的终端设备。</p>
<p>ONT通常安装在用户家庭或办公室，用于接收来自光纤接入网的光信号，并提供网络连接和服务给用户设备。</p>
<p>ONT的主要功能包括：</p>
<ol>
<li><p>光信号接收：ONT接收来自光纤接入网的光信号，并将其转换为电信号进行处理和传输。</p>
</li>
<li><p>数据转发：ONT可以将数据从光纤接入网转发到用户设备，实现网络连接和通信。</p>
</li>
<li><p>用户接口：ONT提供用户接口，用于连接用户设备，如计算机、电话、路由器等，使其能够接入光纤接入网并使用网络服务。</p>
</li>
<li><p>安全管理：ONT可以实施安全策略，保护用户设备和网络安全。</p>
</li>
<li><p>故障检测和排除：ONT可以监测用户设备和光纤接入网的状态和性能，及时发现故障并进行排除。</p>
</li>
</ol>
<p>ONT通常具有小型、低功耗的特点，适合安装在用户终端，提供光纤接入服务。在光纤通信系统中，ONT与OLT之间的连接通常使用以太网协议，如EPON（Ethernet Passive Optical Network）或GPON（Gigabit Passive Optical Network）。</p>
<p>总之，ONT是光纤通信系统中的用户侧设备，用于接收和处理来自光纤接入网的光信号，并提供网络连接和服务给用户设备。它是实现高速、稳定光纤接入服务的重要组成部分。</p>
<h1 id="分光器"><a href="#分光器" class="headerlink" title="分光器"></a>分光器</h1><p>分光器（Splitter）是一种光学设备，用于将光信号分为多个信号，使其可以同时传输到多个目标设备。分光器通常用于光纤通信系统中，特别是在光纤分布式系统（如光纤到户，FTTH）中。</p>
<p>分光器的主要功能是将一路光信号分为多个光信号，使每个信号的功率相等。常见的分光器类型包括平均功率分光器（1×N Splitter）和比例功率分光器（2×N Splitter）。</p>
<p>平均功率分光器将输入的光信号平均分配到多个输出端口上，每个输出端口的功率相等。比例功率分光器可以按照预定的比例分配光信号的功率，例如，将80%的功率分配到一个输出端口，将20%的功率分配到另一个输出端口。</p>
<p>分光器通常使用光纤芯片或光波导技术来实现光信号的分配。它们具有低插入损耗、高分光比、均匀的功率分配和良好的稳定性等特点。</p>
<p>在光纤通信系统中，分光器起到了重要的作用，可以将一路光信号分配给多个用户或设备，实现光纤网络的共享和扩展。</p>
<h1 id="光猫"><a href="#光猫" class="headerlink" title="光猫"></a>光猫</h1><p>光猫（Optical Modem）是一种将光纤信号转换为电信号，并提供网络连接和服务给用户设备的设备。它通常用于光纤接入网络（如光纤到户，FTTH）中，作为用户终端设备，是一种常见ONT。</p>
<p>光猫主要有以下几个功能：</p>
<ol>
<li><p>光信号转换：光猫接收光纤传输的光信号，并将其转换为电信号，以便用户设备可以理解和使用。</p>
</li>
<li><p>网络连接：光猫提供网络连接接口，通常是以太网接口（如RJ45接口），用于将用户设备（如计算机、路由器）连接到光纤网络。</p>
</li>
<li><p>网络服务：光猫通常具有路由器功能，可以提供网络地址转换（NAT）、防火墙、无线局域网（WLAN）等网络服务，以便用户设备可以访问互联网和其他网络资源。</p>
</li>
<li><p>电话服务（可选）：一些光猫还具备电话接口，用于连接传统电话设备，以提供电话服务。</p>
</li>
</ol>
<p>总的来说，光猫是一种将光纤信号转换为电信号，并提供网络连接和服务给用户设备的设备。它在光纤接入网络中起到重要的作用，使用户可以享受高速的光纤网络连接和各种网络服务。</p>
]]></content>
      <tags>
        <tag>网络-Ensp</tag>
      </tags>
  </entry>
  <entry>
    <title>篇2-ISIS</title>
    <url>/2023/09/20/%E7%BD%91%E7%BB%9C-%E7%90%86%E8%AE%BA/%E7%AF%872-ISIS/</url>
    <content><![CDATA[<h1 id="ISIS协议基本原理"><a href="#ISIS协议基本原理" class="headerlink" title="ISIS协议基本原理"></a>ISIS协议基本原理</h1><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><table>
<thead>
<tr>
<th align="center">园区网</th>
<th align="center">骨干网</th>
</tr>
</thead>
<tbody><tr>
<td align="center">应用型网络，主要面向企业网用户</td>
<td align="center">服务型网络，由ISP（网络服务提供商）组建，并为终端用户提供互联网服务</td>
</tr>
<tr>
<td align="center">路由器数量偏少，动态路由的LSDB库容量偏少，三层路由域相对偏少</td>
<td align="center">路由调度占绝对统治地位，路由数量庞大</td>
</tr>
<tr>
<td align="center">有出口路由概念，对内外部路由划分敏感</td>
<td align="center">结构层面扁平化，要求IGP作为基础路由为上层BGP协议服务</td>
</tr>
<tr>
<td align="center">地域性跨度不大，带宽充足，链路状态协议开销对带宽占用偏少</td>
<td align="center">LSDB规模宏大，对链路收敛极度敏感，线路费用高昂</td>
</tr>
<tr>
<td align="center">路由策略和策略路由应用频繁多变，需要精细化的路由操作</td>
<td align="center">最求简单高效，扩展性高，满足各种客户业务需求（IPv6&#x2F;IPX)</td>
</tr>
<tr>
<td align="center">OSPF的多路由类型(内部&#x2F;外部)，多区域类型(骨干&#x2F;通&#x2F;特殊)，开销规则优良(根据带宽设定)，网络类型多样( 最多五种类型)的特点在园区网得到了极大的发挥。</td>
<td align="center">IS-IS的快速算法( PRC得到加强 )，简便报文结构( TLV )，快速居关系建立，大容量路由传递(基于二层开销低)等一系列特点在骨千网有着天然的优势。</td>
</tr>
</tbody></table>
<h2 id="历史起源"><a href="#历史起源" class="headerlink" title="历史起源"></a>历史起源</h2><p>IS-IS最初是国际标准化组织ISO ( the International Organization for Standardization为它的无连接网络协议CLNP ( ConnectionLess Network Protocol) 设计的一种动态路由协议。</p>
<p>为了提供对IP的路由支持，IETF在RFC1195中对IS-IS进行了扩充和修改，使它能够同时应用在TCP&#x2F;IP和OSI环境中，称为集成化IS-IS (Integrated IS-IS )，后面如果没有特别说明提到的IS-IS都是指集成IS-IS。</p>
<p>IS-IS属于内部网关协议，用于自治系统内部。IS-IS是一种链路状态协议，使用最短路径优先算法进行路由计算。</p>
<h2 id="路由计算过程"><a href="#路由计算过程" class="headerlink" title="路由计算过程"></a>路由计算过程</h2><ul>
<li><p>邻居关系建立</p>
<p>邻居关系建立主要是通过HELLO包交互并协商各种参数，包括电路类型(level-1&#x2F;level-2 )，Hold time，网络类型，支持协议，区域号，系统ID，PDU长度，接口IP等。</p>
</li>
<li><p>链路信息交换</p>
<p>与OSPF不同，ISIS交互链路状态的基本载体不是LSA ( link state advertisement ) 而是LSP ( link state PDU)；交互的过程没有OSPF协议那样经历了多个阶段，主要是<u>通过CSNP（Complete Sequence Number PDU）和PSNP（Partial Sequence Number PDU）两种协议报文来同步</u>，请求以及确认链路状态信息(承载的是链路状态信息摘要 )，而链路状态信息的详细拓扑和路由信息是由LSP报文传递。</p>
</li>
<li><p>路由计算</p>
<p>SPF计算和OSPF基本一样的，但ISIS算法分离了拓扑结构和IP网段，加快了网络收敛速度。</p>
</li>
</ul>
<h2 id="地址结构"><a href="#地址结构" class="headerlink" title="地址结构"></a>地址结构</h2><p><img src="/../../images/ISIS/%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84.png"></p>
<p>CLNP（Connectionless Network Protocol），OSI中的网络层协议，类似于TCP&#x2F;IP中的IP协议</p>
<p>CLNS（Connectionless Network Service，无连接网络服务），类似于IP所提供的“尽力而为”的服务，通过CLNP来完成CLNS</p>
<ol>
<li>NPDU（Network protocol Data Unit，网络协议数据单元），是OSI中的网络层协议报文，相当于TCP&#x2F;IP中的IP报文 </li>
<li>NSAP（Network Service Access Point，网络服务接入点），即OSI中的网络层地址，用于多个抽象的网络服务访问点，描述OSI模型的网络地址结构</li>
</ol>
<p>NSAP地址:</p>
<ul>
<li><u>IDP相当于IP地址中的主网络号</u>。它是由ISO规定,并由AF与IDI两部分组成。AFI表示地址分配机构和地址格式，IDI用来标识域。IDP部分是ISO规定的，由AFI (Authority and Format Identifler) 与IDI (Initial Domain Indentifler) 组成，AFI<br>表示地址分配机构和地址格式，<u>IDI 用来标识域。AFI设置为49表示私有。设置为47表示全球。</u></li>
<li><u>DSP相当于IP地址中的子网号和主机地址</u>。它由High Order DSP、System ID和SEL三个部分组成。High Order DSP用来分割区域，System ID用来区分主机, SEL用来指示服务类型。</li>
<li>IDP 和 DSP 都是可变的，NSAP总长最多20个字节，最少8字节</li>
<li>Area Address ( Area ID )，由IDP和DSP中的High Order DSP组成，<u>既能够标识路由域，也能够标识路由域中的区域</u>。因此，它们一起被称为区域地址，相当于OSPF中的区域编号。同一 Level-1 区域的路由器必须具有系统的区域地址，Level-2 区域内的路由可以具有不同的区域地址。区域地址长度是可变的，为1-13字节</li>
<li>System ID，用来在区域内唯一标识主机或路由器，类似OSPF的RID， 在设备的实现中，它的长度固定为48bit( 6字节)，可用MAC地址作为System ID </li>
<li>SEL的作用类似IP中的”协议标识符”， 不同的传输协议对应不同的SEL。在IP上SEL均为00</li>
</ul>
<p>NET :</p>
<ul>
<li>网络实体名称NET指的是设备本身的网络层信息，可以看作是一类特殊的NSAP( SEL&#x3D;00），NET的长度与NSAP的相同，最多为20个字节，最少为8个字节。在路由器上配置IS-IS时,只需要考虑NET即可, NSAP可不必去关注。</li>
<li>在配置IS-IS过程中，NET最多也只能配3个。在配置多个NET时，必须保证它们的System ID都相同。</li>
</ul>
<h2 id="路由器分类"><a href="#路由器分类" class="headerlink" title="路由器分类"></a>路由器分类</h2><p>Level-1路由器:</p>
<ul>
<li>Level-1只能与属于同一区域的Level-1和Level-1-2路由器形成邻居关系，只负责维护Level-1的链路状态数据库，该LSDB包含本区域内的路由信息，到本区域外的报文转发给最近的Level-1-2路由器。Level-1路由器只可能建立Level-1的邻接关系。</li>
</ul>
<p>Level-2路由器:</p>
<ul>
<li>Level-2路由器负责区域间的路由，它可以与相同或者不同区域的Level-2路由器或者不同区域的Level-1-2路由器形成邻居关系。Level-2路由器维护一 个Level-2的LSDB，该LSDB包含区域间的路由信息。Level-2路由器只可能建 立Level-2的邻接关系。</li>
</ul>
<p>Level-1-2路由器:</p>
<ul>
<li>同时属于Level-1和Level-2的路由器称为Level-1-2路由器。Level-1-2路由器维护两个LSDB , Level-1的LSDB用于<strong>区域内</strong>路由，Level-2的LSDB用于<strong>区域间</strong>路由。</li>
<li>Level-1-2路由器可以与同一区域的Level-1形成Level-1邻居关系，也可以与其他区域的 Level-2 和 Level-1-2 路由器形成Level-2的邻居关系。</li>
</ul>
<p>不同区域间，只能建立 Level-2 的邻接关系:</p>
<ul>
<li>Level-2路由器可以与Level-2路由器建立邻接关系。</li>
<li>Level-1-2路由器可以与Level-2路由器建立邻接关系。</li>
<li>Level-1-2路由器可以与Level-1-2路由器建立邻接关系。</li>
</ul>
<p>	</p>
<h2 id="邻居Hello报文"><a href="#邻居Hello报文" class="headerlink" title="邻居Hello报文"></a>邻居Hello报文</h2><p>HELLO PDU ( Hello protocol data unit ) ：</p>
<ul>
<li>HELLO报文的作用是邻居发现，协商参数并建立邻居关系，后期充当保活报文。</li>
<li>IS-IS建立邻居关系和OSPF一样，通过hello报文的交互来完成。但是会根据场景分为三种类型的hello报文。</li>
<li>广播网中的Level-1 IS-IS使用 Level-1 LAN IIH ( Level-1 LAN IS-IS Hello) ，目的组播MAC为: 0180-c200-0014</li>
<li>广播网中的Level-2 IS-IS使用 Level-2 LAN IIH ( Level-2 LAN IS-IS Hello) ，目的组播MAC为: 0180-c200-0015</li>
<li>非广播网络中则使用P2P IIH ( point to point IS-IS Hello)。但是其没有表示DIS （虚节点）的相关字段。</li>
<li>非 IIH 报文需要通过填充字段用于邻居两端协商发送报文的大小。</li>
</ul>
<p>IS-IS支持的网络类型：</p>
<ul>
<li>对点网络类型(P2P)。</li>
<li>广播多路访问网络类型( Broadcast Multiple Access )。</li>
<li>在帧中继等特殊环境下,可以通过创建子接口支持P2P的网络类型。</li>
</ul>
<h2 id="邻居关系建立"><a href="#邻居关系建立" class="headerlink" title="邻居关系建立"></a>邻居关系建立</h2><p><img src="/../../images/ISIS/%E9%82%BB%E5%B1%85%E5%85%B3%E7%B3%BB%E5%BB%BA%E7%AB%8B.png"></p>
<p>在P2P链路上,分为两次握手机制和三次握手机制。</p>
<ul>
<li>两次握手只要路由器收到对端发来的Hello报文，就单方面宣布邻居为up状态，建立邻居关系，不过容易存在单通风险。</li>
<li>通过三次发送P2P的IS-IS Hello PDU最终建立起邻居关系，与广播链路邻居关系的建立情况相同。</li>
</ul>
<p>在广播链路上，用LAN IH报文执行3三次握手建立邻居关系。</p>
<ul>
<li>当收到邻居发送的Hello PDU报文里面没有自己的system ID的时候，状态机进入initialized。</li>
<li>只有收到邻居发过来的Hello PDU有自己的system ID才会up，排除了链路单通的风险。</li>
<li>广播网络中邻居up后会选举DIS(虚节点) ，DIS的功能类似OSPF的DR（指定路由器）。</li>
</ul>
<h2 id="DIS、DIS与DR的类比"><a href="#DIS、DIS与DR的类比" class="headerlink" title="DIS、DIS与DR的类比"></a>DIS、DIS与DR的类比</h2><p><img src="/../../images/ISIS/DIS%E5%92%8CDR%E7%9A%84%E7%B1%BB%E6%AF%94.png"></p>
<p>DIS与伪节点:</p>
<ul>
<li>DIS是指定中间系统 （Designated IS）。</li>
<li>伪节点是指在广播网络中由DIS创建的虚拟路由器。</li>
</ul>
<p>DIS的特点:</p>
<ul>
<li>在广播网络，需要选举DIS ，所以在邻居关系建立后，路由器会<u>等待两个Hello报文间隔</u>再进行DIS的选举。Hello报文中包含Priority 字段，Priority值最大的将被选举为该广播网的DIS。若优先级相同，接口MAC地址较大的被选举为DIS。IS-IS中DIS发送Hello时间间隔默认为10&#x2F;3秒，而其他非DIS路由器发送Hello间隔为10秒。</li>
</ul>
<p>DIS与DR的类比</p>
<ul>
<li>选举时优选级的比较，<u>DIS的优先级为0也可以参与选举</u>。OSPF中优先级为0不参与选举DR。</li>
<li>选举的过程需要一定的时间，OSPF选举DR&#x2F;BDR需要waiting time达40秒，过程也较为复杂，而ISIS选举DIS等待两个Hello报文间隔就可以，简单快捷。</li>
<li>选举结果ISIS只有一个DIS，但是OSPF除了有DR，还有一个BDR用做备份。</li>
<li>选举结束后，后期有新的Router加入到链路进来，如果<u>优先级比DIS高是可抢占的</u>，但是DR是不可抢占的。</li>
<li>选举完成后， ISIS网络链路内所有的路由器之间都建立的是邻接关系。OSPF中<br>DRothers只与 DR&#x2F;BDR 形成 full 邻接关系，DRothers之间只有2-way的关系。</li>
<li>关于DIS和DR的作用:<ol>
<li>进行SPF计算时，都把它当成虚节点，简化MA网络的逻辑拓扑(相同点)。</li>
<li>都是为了减少LSP&#x2F;LSA的泛洪(相同点)。</li>
<li>在ISIS中还可以由DIS发送CSNP来同步链路的LSDB ( ISIS扩展作用)。</li>
</ol>
</li>
</ul>
<h2 id="链路状态信息的载体"><a href="#链路状态信息的载体" class="headerlink" title="链路状态信息的载体"></a>链路状态信息的载体</h2><p><img src="/../../images/ISIS/%E9%93%BE%E8%B7%AF%E7%8A%B6%E6%80%81%E4%BF%A1%E6%81%AF%E7%9A%84%E8%BD%BD%E4%BD%93.png"></p>
<p>ISIS TLV :</p>
<ul>
<li>TLV的含义是：类型(TYPE) ，长度( LENGTH) ，值( VALUE)。实际上是一个数据结构，这个结构包含了这三个字段。</li>
<li>使用TLV结构构建报文的好处是灵活性和扩展性好。采用TLV使得报文的整体结构固定，增加新特点只需要增加新TLV即可。不需要改变整个报文的整体结构。</li>
<li>网络拓扑结构和路由信息用TLV结构表现使得报文的灵活性和扩展性得到了极大的发挥。</li>
</ul>
<p>LSP PDU ( Link State Protocol PDU ) :</p>
<ul>
<li>LSP类似于OSPF的LSA ,承载的是链路状态信息,包含了拓扑结构和网络号。</li>
<li>Level-1 LSP由Level-1路由器传送。</li>
<li>Level-2 LSP由Level-2路由器传送。</li>
<li>Level-1-2路由器则可传送以上两种LSP。</li>
<li>LSP报文中包含了两个重要字段是ATT字段、IS-Type字段。 其中ATT字段用于标识该路由是L1&#x2F;L2路由器发送的, IS-Type用来指明生成此LSP的IS-IS类型是Level-1还是Level-2 IS-IS。</li>
<li>LSP的刷新间隔为15分钟，老化时间为20分钟。但是一条LSP的老化除 了要等待20分</li>
<li>钟外,还要等待60秒的零老化时延; LSP重传时间为5秒。</li>
</ul>
<p>SNP PDU ( Sequence Number PDU ) ：</p>
<ul>
<li>CSNP ( Complete Sequence Number PDU )包括<u>LSDB中所有LSP的摘要</u>信息，从而可以在相邻路由器间保持LSD的同步。</li>
<li>PSNP ( Partial Sequence Number PDU )包含<u>部分LSDB中的LSP摘要</u>信息，能够对LSP进行请求和确认。</li>
<li><u>CSNP类似于OSPF的DD报文传递的是LSDB里所有链路信息摘要。PSNP类似于OSPF的LSR或LSAck报文用于请求和确认部分链路信息。</u></li>
</ul>
<h2 id="链路状态信息的交互"><a href="#链路状态信息的交互" class="headerlink" title="链路状态信息的交互"></a>链路状态信息的交互</h2><p><img src="/../../images/ISIS/%E9%93%BE%E8%B7%AF%E7%8A%B6%E6%80%81%E4%BF%A1%E6%81%AF%E7%9A%84%E4%BA%A4%E4%BA%92.png"></p>
<p>P2P网络LSDB同步过程:</p>
<ul>
<li>建立邻居关系之后，RTA与RTB会先发送CSNP给对端设备。如果对端的LSDB与CSNP没有同步，则发送PSNP请求索取相应的LSP。</li>
<li>假定RTB向RTA索取相应的LSP ，此时向RTA发送PSNP。RTA发送RTB请求的LSP的同时启动LSP重传定时器，并等待RTB发送PSNP作为收到LSP的确认。</li>
<li>如果在接口LSP重传定时器超时后, RTA还没有收到RTB发送的PSNP报文作为应答，则重新发送该LSP直至收到RTB的PSNP报文作为确认。</li>
</ul>
<p>MA网络中新加入的路由器与DIS的LSDB同步交互过程：</p>
<ul>
<li>假设新加入的路由器RTC已经与RTB ( DIS )和RTA建立了邻居关系。</li>
<li>建立邻居关系之后， RTC将自己的LSP发往组播地址( Level-1 : 01-80-C2-00-00-14 ; Level-2 : 01-80-C2-00-00-15 )。这样网络上所有的邻居都将收到该LSP。</li>
<li>该网段中的DIS会把收到RTC的LSP加入到LSDB中,并等待CSNP报文定时器超时( DIS每隔10秒发送CSNP报文）并发送CSNP报文，进行该网络内的LSDB同步。</li>
<li>RTC收到DIS发来的CSNP报文，对比自己的LSDB数据库，然后向DIS发送PSNP报文请求自己没有的LSP (如RTA和RTB的LSP就没有)。</li>
<li>RTB作为DIS收到该PSNP报文请求后向RTC发送对应的LSP进行LSDB的同步。</li>
</ul>
<h2 id="路由算法"><a href="#路由算法" class="headerlink" title="路由算法"></a>路由算法</h2><p><img src="/../../images/ISIS/%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95.png"></p>
<h3 id="IS-IS的计算特点"><a href="#IS-IS的计算特点" class="headerlink" title="IS -IS的计算特点"></a>IS -IS的计算特点</h3><ul>
<li>在本区域内路由器第一次启动的时候执行的是Full-SPF算法。</li>
<li>后续收到的L SP更新，如果是部分拓扑的变化执行的iSPF计算。</li>
<li>如果只是路由信息的变化，执行的就是PRC计算。</li>
<li>由于采用拓扑与网络分离的算法，路由收敛速度得到了加强。</li>
</ul>
<h3 id="ISIS路由计算的开销方式"><a href="#ISIS路由计算的开销方式" class="headerlink" title="ISIS路由计算的开销方式"></a>ISIS路由计算的开销方式</h3><ul>
<li>Narrow模式(设备默认模式开销都是10 ，手工配置接口开销取值范围为1 ~63)。</li>
<li>Wide模式(设备默认模式开销都是10 ，手工配置接口开销取值范围是1~16777215 )。</li>
<li>进程下加入auto-cost enable命令， Narrow模式和Wide模式都会参考接口带宽大小计算开销值，只是参考准则有少许差异。</li>
</ul>
<h2 id="网络分层路由域"><a href="#网络分层路由域" class="headerlink" title="网络分层路由域"></a>网络分层路由域</h2><p><img src="/../../images/ISIS/%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E8%B7%AF%E7%94%B1%E5%9F%9F.png"></p>
<h3 id="IS-IS整体拓扑"><a href="#IS-IS整体拓扑" class="headerlink" title="IS-IS整体拓扑"></a>IS-IS整体拓扑</h3><ul>
<li>为了支持大规模的路由网络， IS-IS在自治系统内采用骨干区域与非骨干区域两级的分层结构。一般来说，将Level-1路由器部署在非骨干区域，Level-2路由器和Level-1-2路由器部署在骨干区域。每一个非骨干区域都通过Level-1-2路由器与骨干区域相连。</li>
<li>拓扑中为一个运行IS-IS协议的网络，它与OSPF的多区域网络拓扑结构非常相似。整个骨干区域不仅包括Level-2的所有路由器，还包括Level-1-2路由器。</li>
<li>Level-1-2级别的路由器可以属于不同的区域,在Level-1区域，维护Level-1的LSDB ，在Level-2区域,维护Level-2的LSDB。</li>
</ul>
<h3 id="拓扑所体现的IS-IS与OSPF不同点"><a href="#拓扑所体现的IS-IS与OSPF不同点" class="headerlink" title="拓扑所体现的IS-IS与OSPF不同点"></a>拓扑所体现的IS-IS与OSPF不同点</h3><ul>
<li>在OSPF中，每个链路只属于一个区域；而在IS-IS中，每个链路可以属于不同的区域;</li>
<li>在IS-IS中，单个区域没有物理的骨干与非骨干区域的概念；而在OSPF中， Area0被定义为骨干区域;</li>
<li><u>在IS IS中，Level-1和Level-2级别的路由器分别采用SPF算法，分别生成最短路径树SPT</u>；<u>在OSPF中，只有在同一个区域内才使用SPF算法，区域之间的路由需要通过骨干区域来转发。</u></li>
</ul>
<h2 id="区域间路由"><a href="#区域间路由" class="headerlink" title="区域间路由"></a>区域间路由</h2><p><img src="/../../images/ISIS/%E5%8C%BA%E5%9F%9F%E9%97%B4%E8%B7%AF%E7%94%B1.png"></p>
<h3 id="Level-1路由器的路由特点"><a href="#Level-1路由器的路由特点" class="headerlink" title="Level-1路由器的路由特点"></a>Level-1路由器的路由特点</h3><ul>
<li>只拥有Level-1的链路状态数据库。</li>
<li>其链路状态数据库中只有本区域路由器LSP。</li>
<li>其路由表里没有其他区域的路由信息。</li>
<li>其路由表里都有一条默认路由，下一条是指向到Level-1 -2路由器。</li>
</ul>
<h3 id="Level-2路由器的路由特点"><a href="#Level-2路由器的路由特点" class="headerlink" title="Level-2路由器的路由特点"></a>Level-2路由器的路由特点</h3><ul>
<li>Level-2路由器只有Level-2的链路状态数据库。</li>
<li>其LSDB中有骨干区域路由器的LSP，但是没有Level-1路由器产生的LSP。</li>
<li>路由表里面有整个网络的路由信息。</li>
</ul>
<h3 id="Level-1-2路由器的路由特点"><a href="#Level-1-2路由器的路由特点" class="headerlink" title="Level-1-2路由器的路由特点"></a>Level-1-2路由器的路由特点</h3><ul>
<li>Level-1-2路由器同时拥有Level-2和L evel-1的链路状态数据库。Level-1数据库包含本区域的LSP , Level-2数据库包含骨干区域LSP。</li>
<li>在自己产生的Level-1的LSP中设置 了ATT比特位为1。</li>
<li>路由表里面有整个网络的路由信息。</li>
</ul>
<h1 id="ISIS与OSPF的区别"><a href="#ISIS与OSPF的区别" class="headerlink" title="ISIS与OSPF的区别"></a>ISIS与OSPF的区别</h1><h2 id="ISIS与OSPF的差异性"><a href="#ISIS与OSPF的差异性" class="headerlink" title="ISIS与OSPF的差异性"></a>ISIS与OSPF的差异性</h2><table>
<thead>
<tr>
<th align="center">差异性</th>
<th align="center">IS-IS</th>
<th align="center">OSPF</th>
</tr>
</thead>
<tbody><tr>
<td align="center">网络类型</td>
<td align="center">少</td>
<td align="center">多</td>
</tr>
<tr>
<td align="center">开销方式</td>
<td align="center">复杂</td>
<td align="center">简便</td>
</tr>
<tr>
<td align="center">区域类型</td>
<td align="center">少</td>
<td align="center">多</td>
</tr>
<tr>
<td align="center">路由报文类型</td>
<td align="center">简单</td>
<td align="center">多样</td>
</tr>
<tr>
<td align="center">路由收敛速度</td>
<td align="center">很快</td>
<td align="center">快</td>
</tr>
<tr>
<td align="center">扩展性</td>
<td align="center">强</td>
<td align="center">一般</td>
</tr>
<tr>
<td align="center">路由负载能力</td>
<td align="center">超强</td>
<td align="center">强</td>
</tr>
</tbody></table>
<h3 id="网络类型和开销方式"><a href="#网络类型和开销方式" class="headerlink" title="网络类型和开销方式"></a>网络类型和开销方式</h3><p>IS-IS协议只支持两种网络类型，且所有带宽默认开销值都是-样的，OSPF协议支持四种网络类型，且会根据不同的带宽设定相应的开销值， 对帧中继，按需链路等网络类型有很好的支持。</p>
<h3 id="区域类型"><a href="#区域类型" class="headerlink" title="区域类型"></a>区域类型</h3><p>IS-IS协议分L1&#x2F;L2区域，L2区域是骨干区域有全部明细路由。L1去往L2只有默认路由。OSPF协议分骨干区域，普通区域，特殊区域。普通区域和特殊区域跨区域访问需要经过骨干区域。</p>
<h3 id="报文类型"><a href="#报文类型" class="headerlink" title="报文类型"></a>报文类型</h3><p>IS-IS协议路由承载报文类型只有LSP报文且里面路由信息是不区分内部与外部的，简单高效，无需递归计算。OSPF协议路由承载报文LSA类型多样，有1&#x2F;2&#x2F;3&#x2F;4&#x2F;5&#x2F;7类等。路由级别等级森严，且需要递归计算,适合精细化调度计算。</p>
<h3 id="路由算法-1"><a href="#路由算法-1" class="headerlink" title="路由算法"></a>路由算法</h3><p>ISIS协议区域内某个节点上的网段发生变化时，触发的是PRC算法，收敛比较快，计算路由的报文开销也比较小。OSPF协议由于网络地址参与了拓扑的构建，在区域内当网段地址改变触发的是i-spf算法，相对来说过程繁琐复杂些。</p>
<h3 id="扩展性"><a href="#扩展性" class="headerlink" title="扩展性"></a>扩展性</h3><p>ISIS协议任何路由信息都使用TLV传递,结构简单，易于扩展，如对IPv6的支持只增加2个TLV就解决了。且ISIS本身对IPX等协议是支持的。OSPF协议本身是为IP特定开发的，支持IPv4和IPv6的OSPF协议是两个独立的版本( OSPFv2和OSPFv3 )。</p>
<h2 id="术语对照"><a href="#术语对照" class="headerlink" title="术语对照"></a>术语对照</h2><p><img src="/../../images/ISIS/%E6%9C%AF%E8%AF%AD%E5%AF%B9%E7%85%A7.png"></p>
<h1 id="ISIS应用场景配置"><a href="#ISIS应用场景配置" class="headerlink" title="ISIS应用场景配置"></a>ISIS应用场景配置</h1><p><img src="/../../images/ISIS/%E6%95%99%E6%9D%90%E5%AE%9E%E9%AA%8C%E6%8B%93%E6%89%91.png"></p>
<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><ul>
<li>所有路由启用IS-IS，进程号为100，全网路由可达</li>
<li>AR1 在 Area 49.0001 区域为DIS</li>
<li>AR4 与 AR5 之间采用P2P网络类型</li>
<li>AR5 引入直连路由192.168.x.x</li>
<li>AR1 访问 Area 49.0002 走最优路径</li>
</ul>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ul>
<li><p>所有接口配置ip</p>
</li>
<li><p>AR1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[AR1-isis-100]dis this</span><br><span class="line">[V200R003C00]</span><br><span class="line">#</span><br><span class="line">isis 100</span><br><span class="line"> is-level level-1</span><br><span class="line"> network-entity 49.0001.0000.0000.0001.00</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line">//接口配置</span><br><span class="line">[AR1-GigabitEthernet0/0/0]dis this</span><br><span class="line">[V200R003C00]</span><br><span class="line">#</span><br><span class="line">interface GigabitEthernet0/0/0</span><br><span class="line"> ip address 10.1.123.1 255.255.255.0 </span><br><span class="line"> isis enable 100</span><br><span class="line"> isis dis-priority 120 level-1      //配置高优先级，成为DIS</span><br><span class="line">#</span><br></pre></td></tr></table></figure>
</li>
<li><p>AR2</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[AR2-isis-100]dis this</span><br><span class="line">[V200R003C00]</span><br><span class="line">#</span><br><span class="line">isis 100</span><br><span class="line"> network-entity 49.0001.0000.0000.0002.00</span><br><span class="line"> import-route isis level-2 into level-1       //路由渗透</span><br><span class="line">#</span><br><span class="line">//默认为level-1-2</span><br></pre></td></tr></table></figure>
</li>
<li><p>AR3</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[AR3-isis-100]dis this</span><br><span class="line">[V200R003C00]</span><br><span class="line">#</span><br><span class="line">isis 100</span><br><span class="line"> network-entity 49.0001.0000.0000.0003.00</span><br><span class="line"> import-route isis level-2 into level-1      //路由渗透</span><br><span class="line">#</span><br><span class="line">//默认为level-1-2</span><br></pre></td></tr></table></figure>
</li>
<li><p>AR4</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[AR4-isis-100]dis this</span><br><span class="line">[V200R003C00]</span><br><span class="line">#</span><br><span class="line">isis 100</span><br><span class="line"> is-level level-2</span><br><span class="line"> network-entity 49.0002.0000.0000.0004.00</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line">//特殊接口配置</span><br><span class="line">[AR4-GigabitEthernet0/0/0]dis this</span><br><span class="line">[V200R003C00]</span><br><span class="line">#</span><br><span class="line">interface GigabitEthernet0/0/0</span><br><span class="line"> ip address 10.1.45.4 255.255.255.0 </span><br><span class="line"> isis enable 100</span><br><span class="line"> isis circuit-type p2p               //接口网络类型修改为P2P</span><br><span class="line">#</span><br><span class="line">return</span><br></pre></td></tr></table></figure>
</li>
<li><p>AR5</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[AR5-isis-100]dis this</span><br><span class="line">[V200R003C00]</span><br><span class="line">#</span><br><span class="line">isis 100</span><br><span class="line"> is-level level-2</span><br><span class="line"> network-entity 49.0002.0000.0000.0005.00</span><br><span class="line"> import-route direct                  //引入直连路由</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line">[AR5-GigabitEthernet0/0/0]dis this</span><br><span class="line">[V200R003C00]</span><br><span class="line">#</span><br><span class="line">interface GigabitEthernet0/0/0</span><br><span class="line"> ip address 10.1.45.5 255.255.255.0 </span><br><span class="line"> isis enable 100</span><br><span class="line"> isis circuit-type p2p               //接口网络类型修改为P2P</span><br><span class="line">#</span><br><span class="line">return</span><br></pre></td></tr></table></figure>
</li>
<li><p>所有接口开启ISIS</p>
</li>
</ul>
<h2 id="路由渗透"><a href="#路由渗透" class="headerlink" title="路由渗透"></a>路由渗透</h2><ul>
<li><u>如果一个level-1区域有两个以上Level-1-2路由器，则区域内Level-1路由器访问其他区域会选择最近的Level-1-2路由器，但是计算的开销值只计算本区域内的，如果最近的Level-1-2路由器在Level-2区域到达目的网络的开销相对比较大，实际会造成业务次优路径。</u>在这种场景下需要做路由渗透操作，把Level-2区域的明细路由(包括开销)引入到Level-1区域，由Level-1路由器自行计算选择最优的路径访问跨区域网络</li>
<li>本实例要求走最优的路径到达区域49.0002，由于RTB连接RTD的链路带宽相对比较大，作用最好让数据流走RTB。可分别在RTB和RTC的ISIS进程下引入level-2的路由到level-1。由RTA的LSDB里面掌握level-2所有的明细路由，就可以选择最优的路径到达区域49.0002。</li>
</ul>
]]></content>
      <tags>
        <tag>网络-理论</tag>
      </tags>
  </entry>
  <entry>
    <title>篇1 OSPF核心知识</title>
    <url>/2023/08/16/%E7%BD%91%E7%BB%9C-%E7%90%86%E8%AE%BA/%E7%AF%871-ospf/</url>
    <content><![CDATA[<h1 id="OSPF-基础"><a href="#OSPF-基础" class="headerlink" title="OSPF 基础"></a>OSPF 基础</h1><h2 id="OSPF-工作过程"><a href="#OSPF-工作过程" class="headerlink" title="OSPF 工作过程"></a>OSPF 工作过程</h2><p>OSPF的路由计算过程可以简化描述为︰</p>
<ol>
<li>路由器之间发现并建立邻居关系。</li>
<li>每台路由器产生并向邻居泛洪链路状态信息，同时收集来自其他路由器链路状态信息，完成LSDB ( Link StateDatabase)的同步。</li>
<li>每台路由器基于LSDB通过SPF算法，计算得到一棵以自己为根的SPT ( ShortestPath Tree)，再以SPT为基础计算去往各目的网络的最优路由，并形成路由表。</li>
</ol>
<h2 id="邻居建立"><a href="#邻居建立" class="headerlink" title="邻居建立"></a>邻居建立</h2><h3 id="Router-ID"><a href="#Router-ID" class="headerlink" title="Router ID"></a>Router ID</h3><p>Router ID是一个32位的无符号整数，其格式和IP地址的格式是一样的，用于标识每个路由器，Router ID选举规则如下︰</p>
<ul>
<li>手动配置OSPF路由器的Router ID(通常建议手动配置）;</li>
<li>如果没有手动配置Router ID，则路由器使用Loopback接口中最大的IP地址作为Router ID ;</li>
<li>如果没有配置Loopback接口，则路由器使用物理接口中最大的IP地址作为Router ID</li>
</ul>
<h3 id="Hello报文的作用"><a href="#Hello报文的作用" class="headerlink" title="Hello报文的作用"></a>Hello报文的作用</h3><ul>
<li><p>邻居发现：自动发现邻居路由器</p>
</li>
<li><p>邻居建立：完成Hello报文中参数协商，建立邻居关系</p>
</li>
<li><p>邻居保持：邻居关系建立后，会周期性地发送Hello报文，一定时间内未收到邻居的Hello报文则中断邻居关系</p>
</li>
<li><img src="/images/OSPF/%E9%82%BB%E5%B1%85%E5%BB%BA%E7%AB%8B%E8%BF%87%E7%A8%8B%E5%9B%BE.png" class="center" title="邻居建立过程图">

<h4 id="状态信息"><a href="#状态信息" class="headerlink" title="状态信息"></a>状态信息</h4></li>
<li><p>Down：这是邻居的初始状态，表示没有从邻居收到任何信息</p>
</li>
<li><p>Init：在此状态下，路由器已经从邻居收到了Hello报文，但是自己的Router ID不在所收到的Hello报文的邻居列表中，表示尚未与邻居建立双向通信关系。</p>
</li>
<li><p>2-Way：在此状态下，路由器发现自己的Router ID存在于收到的Hello报文的邻居列表中，已确认可以双向通信。</p>
<h4 id="建立过程"><a href="#建立过程" class="headerlink" title="建立过程"></a>建立过程</h4></li>
<li><p>RouterA启动OSPF后，发送第一个Hello报文。此时邻居列表为空，状态为Down，一旦RouterB接收到来自RouterA的这个报文，RouterB状态从Down转换成Init</p>
</li>
<li><p>同理，RouterB发送第一个Hello报文，RouterA接收后转化成Init状态</p>
</li>
<li><p>RTB向RTA发送邻居列表为1.1.1.1的Hello报文，RTA在收到的Hello报文邻居列表中发现自己的Router ID，状态置为2-way。</p>
</li>
<li><p>同理，RTA向RTB发送邻居列表为2.2.2.2的Hello报文，RTB状态转换成2-way</p>
</li>
</ul>
<p>由于邻居都是未知的，OSPF采用组播的形式发送Hello报文，对于不支持组播的网络，可以手动配置建立邻居</p>
<p>过程①和过程②顺序可以互换，③和④顺序可以互换</p>
<h2 id="链路状态信息"><a href="#链路状态信息" class="headerlink" title="链路状态信息"></a>链路状态信息</h2><p>建立邻居关系是为了同步链路状态信息</p>
<p>OSPF路由器同步最原始的链路状态信息，对于邻居发来的链路状态信息，仅做转发，最终所有路由器将拥有一份相同且完整的原始链路状态信息</p>
<p>每台OSPF路由器所描述的信息都应该包括：</p>
<ul>
<li>链路类型</li>
<li>接口IP</li>
<li>掩码</li>
<li>链路邻居</li>
<li>链路开销 等信息</li>
</ul>
<p>OSPF划分了四种网络类型，并以此组成拓扑信息的一部分：</p>
<ul>
<li>P-2-P</li>
<li>MA</li>
<li>NBMA （非广播型多路访问。当链路层协议是 帧中继、ATM或X.25时，OSPF缺省认为网络类型是NBMA，默认不支持广播和组播，需要手动配置邻居）</li>
<li>P2MP （点到多点。必须是由其他网络强制更改的，支持广播和组播）</li>
</ul>
<h2 id="OSPF度量方式"><a href="#OSPF度量方式" class="headerlink" title="OSPF度量方式"></a>OSPF度量方式</h2><p> OSPF在计算接口的cost时，cost&#x3D;参考带宽&#x2F;实际带宽，默认参考带宽为100M。当计算结果有小数位时，只取整数位﹔结果小于1时，cost取1。</p>
<p>若需要调整接口cost值有两种方式∶</p>
<ul>
<li>直接在接口下配置，需要注意的是，配置的cost是此接口最终的cost值，作用范围仅 限于本接口。</li>
<li>修改OSPF的默认参考带宽值，作用范围是本路由器使能OSPF的接口。建议参考整个网络的带宽情况建立参考基线，所有路由器修改相同的参考带宽值，从而确保选路的—致性。</li>
<li>OSPF以“累计cost”为开销值，也就是流量从源网络到目的网络所经过所有路由器的出接口的cost总和</li>
</ul>
<h2 id="报文类型及作用"><a href="#报文类型及作用" class="headerlink" title="报文类型及作用"></a>报文类型及作用</h2><p><img src="/../../images/OSPF/OSPF%E6%8A%A5%E6%96%87%E5%A4%B4%E9%83%A8.png"></p>
<p>RIP路由器之间是基于UDP 520的报文进行通信，OSPF也有其规定的通信标准。OSPF使用IP承载其报文，协议号为89。<br>在OSPF Packet部分，所有的OSPF报文均使用相同的OSPF报文头部∶</p>
<ul>
<li>Version：对于当前所使用的OSPFv2，该字段的值为2。</li>
<li>Type：OSPF报文类型。</li>
<li>Packet length：表示整个OSPF报文的长度，单位是字节。 </li>
<li>Router ID:表示生成此报文的路由器的Router ID。</li>
<li>Area ID：表示此报文需要被通告到的区域。</li>
<li>Checksum：校验字段，其校验的范围是整个OSPF报文，包括OSPF报文头部。 </li>
<li>Auth Type：为0时表示不认证;为1时表示简单的明文密码认证﹔为2时表示加密( MD5)认证。</li>
<li>Authentication：认证所需的信息。该字段的内容随AuType的值不同而不同。</li>
</ul>
<h3 id="报文类型"><a href="#报文类型" class="headerlink" title="报文类型"></a>报文类型</h3><table>
<thead>
<tr>
<th align="center">Type值</th>
<th align="center">报文名称</th>
<th align="center">报文功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">Hello</td>
<td align="center">发现和维护邻居关系</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">Database Description</td>
<td align="center">交互链路状态数据库摘要</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">Link State Request</td>
<td align="center">请求特定链路状态信息</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">Link State Update</td>
<td align="center">发送详细链路状态信息</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">Link State Ack</td>
<td align="center">发送确认报文</td>
</tr>
</tbody></table>
<ol>
<li>Hello报文，用来建立和维护邻居关系，邻居关系建立之前，路由器之间需要进行参数协商。</li>
<li>数据库描述报文（DD)，用来向邻居路由器描述本地链路状态数据库，使得邻居路由器识别出数据库中的LSA是否完整。</li>
<li>链路状态请求报文(LSR），路由器根据邻居的DD报文，判断本地数据库是否完整，如不完整，路由器把这些LSA记录进链路状态请求列表中，然后发送一个LSR给邻居路由器。</li>
<li>链路状态更新报文(LSU )，用于响应邻居路由器发来的LSR，根据LSR中的请求列表，发送对应LSA给邻居路由器，真正实现LSA的泛洪与同步。</li>
<li>链路状态确认报文(LSAck )，用来对收到的LSA进行确认，保证同步过程的可靠性。</li>
</ol>
<p>与LSA的关系：</p>
<ul>
<li>DD报文中包含LSA头部信息，包括LS Type、LS ID、Advertising Router 、 LS Sequence Number、Ls Checksum。</li>
<li>LSR中包含LS Type 、 LS ID和Advertising Router </li>
<li>LSU中包含完整的LSA信息。</li>
<li>LSAck中包含LSA头部信息，包括LS Type、LS ID、Advertising Router、LS Sequence Number、LS Checksum。</li>
</ul>
<h2 id="LSDB-同步过程"><a href="#LSDB-同步过程" class="headerlink" title="LSDB 同步过程"></a>LSDB 同步过程</h2><p><strong>状态含义：</strong></p>
<ul>
<li>ExStart：邻居状态变成此状态以后，路由器开始向邻居发送DD报文。Master&#x2F;Slave关系是在此状态下形成的，初始DD序列号也是在此状态下确定的。在此状态下发送的DD报文不包含链路状态描述。</li>
<li>Exchange：在此状态下，路由器与邻居之间相互发送包含链路状态信息摘要的DD报文。</li>
<li>Loading：在此状态下，路由器与邻居之间相互发送LSR报文、LSU报文、LSAck报文。</li>
<li>Full：LSDB同步过程完成，路由器与邻居之间形成了完全的邻接关系。</li>
</ul>
<h3 id="过程一"><a href="#过程一" class="headerlink" title="过程一"></a>过程一</h3><img src="/images/OSPF/LSDB%E5%90%8C%E6%AD%A5%E4%B8%80.png" class="center" title="LSDB同步一">

<p><strong>过程描述</strong>：</p>
<ol>
<li><p>RTA和RTB的Router ID分别为1.1.1.1和2.2.2.2并且二者已建立了邻居关系。当RTA的邻居状态变为ExStart后，RTA会发送第一个DD报文。此报文中，DD序列号被随机设置为X，I-bit设置为1，表示这是第一个DD报文，M-bit设置为1，表示后续还有DD报文要发送，MS-bit设置为1，表示RTA宣告自己为Master。</p>
</li>
<li><p>当RTB的邻居状态变为ExStart后，RTB会发送第一个DD报文。此报文中，DD序列号被随机设置为Y ( I-bit&#x3D;1，M-bit&#x3D;1，MS-bit&#x3D;1，含义同上)。由于RTB的RouterID较大，所以RTB将成为真正的Master。收到此报文后，RTA会产生一个Negotiation-Done事件，并将邻居状态从ExStart变为Exchange。</p>
</li>
<li><p>当RTA的邻居状态变为Exchange后，RTA会发送一个新的DD报文，此报文中包含了LSDB的摘要信息，序列号设置为RTB在步骤2中使用的序列号Y，I-bit&#x3D;0，表示这不是第一个DD报文，M-bit&#x3D;O，表示这是最后一个包含LSDB摘要信息的DD报文，MS-bit&#x3D;0，表示RTA宣告自己为Slave。收到此报文后，RTB会产生一个Negotiation-Done事件，并将邻居状态从ExStart变为Exchange。</p>
</li>
<li><p>当RTB的邻居状态变为Exchange后，RTB会发送一个新的DD报文，此报文包含了LSDB的摘要信息，DD序列号设置为Y+1,MS-bit&#x3D;1，表示RTB宣告自己为Master。</p>
</li>
<li><p>虽然RTA不需要发送新的包含LSDB摘要信息的DD报文，但是作为Slave，RTA需要对Master发送的每一个DD报文进行确认。所以，RTA向RTB发送一个新的DD报文，序列号为Y+1，该报文内容为空。发送完此报文后，RTA产生一个Exchange-Done事件，将邻居状态变为Loading。RTB收到此报文后，会将邻居状态变为Full(假设RTB的LSDB是最新最全的，不需要向RTA请求更新)。</p>
</li>
</ol>
<p><strong>DD报文重要字段参数对照表：</strong></p>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">含义</th>
<th align="center">0</th>
<th align="center">1</th>
</tr>
</thead>
<tbody><tr>
<td align="center">I</td>
<td align="center">是否为第一个DD报文</td>
<td align="center">否</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">M</td>
<td align="center">是否后续还有（包含LSDB摘要的）DD报文</td>
<td align="center">否</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">MS</td>
<td align="center">主从关系</td>
<td align="center">从</td>
<td align="center">主</td>
</tr>
</tbody></table>
<h3 id="过程二"><a href="#过程二" class="headerlink" title="过程二"></a>过程二</h3><p><img src="/../../images/OSPF/LSDB%E5%90%8C%E6%AD%A5%E4%BA%8C.png"></p>
<p><strong>过程描述</strong></p>
<ol>
<li><p>RTA开始向RTB发送LSR报文，请求那些在Exchange状态下通过DD报文发现的、并且在本地LSDB中没有的链路状态信息。</p>
</li>
<li><p>RTB向RTA发送LSU报文，LSU报文中包含了那些被请求的链路状态的详细信息。RTA在完成LSU报文的接收之后，会将邻居状态从Loading变为Full。</p>
</li>
<li><p>RTA向RTB发送LSAck报文，作为对LSU报文的确认。RTB收到LSAck报文后，双方便建立起了完全的邻接关系。</p>
</li>
</ol>
<h3 id="OSPF邻居状态机（状态流程图）"><a href="#OSPF邻居状态机（状态流程图）" class="headerlink" title="OSPF邻居状态机（状态流程图）"></a>OSPF邻居状态机（状态流程图）</h3><p><img src="/../../images/OSPF/%E9%82%BB%E5%B1%85%E7%8A%B6%E6%80%81%E6%9C%BA.png"></p>
<ul>
<li>Attempt状态只存在于NBMA网络，周期性发送Hello报文，但未收到邻居回应，发送间隔为Hello Interva，若在DeadInterval内未收到邻居的Hello，则转变成Down</li>
<li>Init状态下，发生2-Way Received 事件后，若需要与邻居建立邻接关系则进入ExStart状态，否则进入2-Way状态</li>
<li>1-Way Received：此事件表示路由器发现自己没有在邻居发送Hello报文的邻居列表中，通常是由于对端邻居重启造成的。</li>
</ul>
<h3 id="LSA头部"><a href="#LSA头部" class="headerlink" title="LSA头部"></a>LSA头部</h3><p><img src="/../../images/OSPF/LSA%E5%A4%B4%E9%83%A8.png"></p>
<p>LSA ( Link State Advertisement )是路由器之间链路状态信息的载体。LSA是LSDB的最小组成单位，也就是说LSDB由一条条LSA构成的。<br>所有的LSA都拥有相同的头部，关键字段的含义如下∶ </p>
<ul>
<li>LS age : 此字段表示LSA已经生存的时间，单位是秒。</li>
<li>LS type : 此字段标识了LSA的格式和功能。常用的LSA类型有五种。</li>
<li>Link State ID:此字段是该LSA所描述的那部分链路的标识，例如Router ID等</li>
<li>Advertising Router : 此字段是产生此LSA的路由器的Router ID。</li>
<li>LS sequence number : 此字段用于检测旧的和重复的LSA。</li>
</ul>
<p>LS type,Link State ID和Advertising Router的组合共同标识一条LSA。<br>LSDB中除了自己生成的LSA，另一部分是从邻居路由器接收的。邻居路由器之间相互更新LSA必然需要一个“通道”。</p>
<h2 id="DR与BDR的选举及作用"><a href="#DR与BDR的选举及作用" class="headerlink" title="DR与BDR的选举及作用"></a>DR与BDR的选举及作用</h2><p>DR ( Designated Router )即指定路由器，其负责在MA网络建立和维护邻接关系并负责LSA的同步。</p>
<p>DR与其他所有路由器形成邻接关系并交换链路状态信息，其他路由器之间不直接交换链路状态信息。这样就大大减少了MA网络中的邻接关系数量及交换链路状态信息消耗的资源。</p>
<p>DR一旦出现故障，其与其他路由器之间的邻接关系将全部失效，链路状态数据库也无法同步。此时就需要重新选举DR，再与非DR路由器建立邻接关系，完成LSA的同步。为了规避单点故障风险，通过选举备份指定路由器BDR，在DR失效时快速接管DR的工作。</p>
<p>伪节点是一个虚拟设备节点，其功能需要某台路由器来承载。</p>
<p>选举规则：</p>
<ul>
<li>DR&#x2F;BDR 的选举是基于<strong>接口</strong>的</li>
<li>先选举 BDR，当BDR选举完成后，发现没有DR，则BDR自动变成DR，当有DR，则BDR不变。</li>
<li>接口的DR priority越大越优先，DR priority 默认为1，若为0则只能成为 DRother</li>
<li>DR priority相等时，RouterID越大越优先</li>
</ul>
<p>邻居与邻接关系</p>
<table>
<thead>
<tr>
<th>网络类型</th>
<th>是否和邻居建立邻接关系</th>
</tr>
</thead>
<tbody><tr>
<td>P2P</td>
<td>是</td>
</tr>
<tr>
<td>Broadcast、NBMA</td>
<td>DR与BDR、DRother建立邻接关系；BDR与DR、 DRother建立邻接关系, DRother之间只建立邻居关系</td>
</tr>
<tr>
<td>P2MP</td>
<td>是</td>
</tr>
</tbody></table>
<ul>
<li>邻居(Neighbor )关系与邻接(Adjacency )关系是两个不同的概念。OSPF路由器之间建立邻居关系后，进行LSDB同步，最终形成邻接关系。</li>
<li>在P2P网络及P2MP网络上，具有邻居关系的路由器之间会进一步建立邻接关系。</li>
<li>在广播型网络及NBMA网络上，非DR&#x2F;BDR路由器之间只能建立邻居关系，不能建立邻接关系，非DR&#x2F;BDR路由器与DR&#x2F;BDR路由器之间会建立邻接关系，DR与BDR之间也会建立邻接关系。</li>
<li>邻接关系建立完成，意味着LSDB已经完成同步，接下来OSPF路由器将基于LSDB使用SPF算法计算路由。</li>
</ul>
<h1 id="OSPF-路由计算"><a href="#OSPF-路由计算" class="headerlink" title="OSPF 路由计算"></a>OSPF 路由计算</h1><h2 id="区域内路由计算"><a href="#区域内路由计算" class="headerlink" title="区域内路由计算"></a>区域内路由计算</h2><h3 id="Router-LSA"><a href="#Router-LSA" class="headerlink" title="Router LSA"></a>Router LSA</h3><h4 id="P2P"><a href="#P2P" class="headerlink" title="P2P"></a>P2P</h4><p><img src="/../../images/OSPF/p2pRouterLSA.png"></p>
<p>一条Router-LSA可以描述多条链接，每条链接描述信息由Link ID，Data，Link Type和Metric组成，其关键字含义如下︰</p>
<ul>
<li>Type∶链接类型(并非OSPF定义的四种网络类型），Router LSA描述的链接类型主要有︰</li>
</ul>
<ol>
<li>Point-to-Point:描述一个从本路由器到邻居路由器之间的点到点链接，属于<br>拓扑信息。</li>
<li>TransNet:描述一个从本路由器到一个Transit网段（例如MA网段或者NBMA网段）的链接，属于拓扑信息。</li>
<li>StubNet:描述一个从本路由器到一个Stub网段（例如Loopback接口）的链接，属于路由信息。</li>
</ol>
<ul>
<li>Link ID: 此链接的对端标识，不同链接类型的Link ID表示的意义也不同。</li>
<li>Data:用于描述此链接的附加信息，不同的链接类型所描述的信息也不同。</li>
<li>Metric:描述此链接的开销。</li>
</ul>
<h4 id="MA或NBMA"><a href="#MA或NBMA" class="headerlink" title="MA或NBMA"></a>MA或NBMA</h4><p><img src="/../../images/OSPF/MARouterLSA.png"></p>
<p>在描述MA或NBMA网络类型的Router-LSA中，</p>
<ul>
<li>Link ID为DR的接口IP地址，</li>
<li>Data为本地接口的IP地址。</li>
<li>如图所示，RTB、RTC、RTE之间通过以太链路互连，以RTC产生的LSA为例，Link ID为DR的接口IP地址(10.1.235.2 ) ，Data为本地路由器连接此MA网络的接口IP地址(10.1.235.3 )，Link Type为TransNet ，Metric表示到达DR的开销值。</li>
<li>TransNet描述的链接中仅包括与DR的连接关系及开销，没有网络号&#x2F;掩码及共享链路上其他路由器的任何信息。</li>
</ul>
<h3 id="Network-LSA"><a href="#Network-LSA" class="headerlink" title="Network LSA"></a>Network LSA</h3><h4 id="MA或NBMA网络"><a href="#MA或NBMA网络" class="headerlink" title="MA或NBMA网络"></a>MA或NBMA网络</h4><img src="/images/OSPF/MANetworkLSA.png" class="center" title="MA Network LSA" alt="hhh">	

<p>MA共享网段或NBMA共享网段中的网络号&#x2F;掩码及路由器间的链接关系，通过Network-LSA来呈现。<br>在Network-LSA中关键字的含义如下︰</p>
<ul>
<li>Type : LSA类型，Network-LSA是二类LSA。 </li>
<li>LS id : DR的接口IP地址。</li>
<li>Adv rtr : 产生此Network-LSA的路由器Router ID，即DR的Router ID。 </li>
<li>Net mask :该网段的网络掩码。</li>
<li>Attached Router:连接到该网段的路由器列表，呈现了此网段的拓扑信息。</li>
</ul>
<p>基于上述字段表达的信息，Ls id和Net mask做与运算，即可得出该网段的IP网络号，<strong>另外从DR路由器到其所连接的路由器的开销为0。</strong><br>从Attached Router部分可以看出，2.2.2.2、3.3.3.3、5.5.5.5共同连接到该共享MA网段中，DR路由器为2.2.2.2，网络号10.1.235.0，掩码255.255.255.0。</p>
<h3 id="重要字段对照表"><a href="#重要字段对照表" class="headerlink" title="重要字段对照表"></a>重要字段对照表</h3><table>
<thead>
<tr>
<th align="center">LSA类型</th>
<th align="center">Ls id</th>
<th align="center">Adv rtr</th>
</tr>
</thead>
<tbody><tr>
<td align="center">router</td>
<td align="center">链路状态id（一般为router ID)</td>
<td align="center">产生此LSA路由器的router ID</td>
</tr>
<tr>
<td align="center">network</td>
<td align="center">DR 接口IP</td>
<td align="center">DR 的router ID</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">Router LSA 的Link Type</th>
<th align="center">Link ID</th>
<th align="center">Data</th>
</tr>
</thead>
<tbody><tr>
<td align="center">P-2-P（拓扑信息）</td>
<td align="center">邻居的router ID</td>
<td align="center">宣告该LSA的接口IP（一般为自身接口）</td>
</tr>
<tr>
<td align="center">TransNet（拓扑信息）</td>
<td align="center">DR 接口IP</td>
<td align="center">同上</td>
</tr>
<tr>
<td align="center">StubNet（路由信息）</td>
<td align="center">Stub网段IP</td>
<td align="center">网段掩码</td>
</tr>
</tbody></table>
<h3 id="构建SPF树（相同区域内）"><a href="#构建SPF树（相同区域内）" class="headerlink" title="构建SPF树（相同区域内）"></a>构建SPF树（相同区域内）</h3><p><strong>网络拓扑图如下</strong>（router1至router5分别对应routerA至routerE，router ID分别为1.1.1.1 ~ 5.5.5.5）</p>
<p><img src="/../../images/OSPF/%E6%95%99%E6%9D%90%E6%8B%93%E6%89%91%E5%9B%BE.png"></p>
<ol>
<li>以routerA为根节点，构建SPF树</li>
<li>查看routerA的router LSA（拓扑信息），将除StubNet外的连接加入候选列表中，并选择候选列表中开销最小的作为下一个节点。这里是10.1.12.2，且为DR</li>
</ol>
<p><img src="/../../images/OSPF/%E6%9E%84%E5%BB%BASPF%E6%A0%911.png"></p>
<ol start="3">
<li>查看10.1.12.2的network LSA （网络接入信息），将未出现过的节点加入候选列表中，并选择列表中现有开销最小的作为下一节点。下一节点是 2.2.2.2，开销为0</li>
</ol>
<p><img src="/../../images/OSPF/%E6%9E%84%E5%BB%BASPF%E6%A0%912.png"></p>
<ol start="4">
<li>继续查看 2.2.2.2 的router LSA（拓扑信息），将未出现的连接加入候选列表中，选择开销最小的作为下一个节点。此处选择 DR10.1.235.2</li>
</ol>
<p><img src="/../../images/OSPF/%E6%9E%84%E5%BB%BASPF%E6%A0%913.png"></p>
<ol start="5">
<li>接着查看 DR 10.1.235.2的network LSA（网络接入信息），将 3.3.3.3 和 5.5.5.5 加入候选列表，两者开销值相同，且与之前剩余的 3.3.3.3 对比，当前3.3.3.3开销更小，则有两个子节点</li>
</ol>
<p><img src="/../../images/OSPF/%E6%9E%84%E5%BB%BASPF%E6%A0%914.png"></p>
<ol start="6">
<li>查看 3.3.3.3 的router LSA，发现连接都已存在，直接忽略</li>
</ol>
<p><img src="/../../images/OSPF/%E6%9E%84%E5%BB%BASPF%E6%A0%915.png"></p>
<ol start="7">
<li>查看 5.5.5.5 的router LSA 将 4.4.4.4 加入候选列表，发现和之前剩余对比，开销较大，选择之前留下的 4.4.4.4 作为SPF树节点，开销值为49，父节点为 2.2.2.2。至此，SPF树构建完毕。</li>
</ol>
<p><img src="/../../images/OSPF/%E6%9E%84%E5%BB%BASPF%E6%A0%916.png"></p>
<h3 id="计算最优路由"><a href="#计算最优路由" class="headerlink" title="计算最优路由"></a>计算最优路由</h3><p><img src="/../../images/OSPF/%E8%AE%A1%E7%AE%97%E6%9C%80%E4%BC%98%E8%B7%AF%E7%94%B1.png"></p>
<p>从根节点开始，依次添加LSA中的路由信息（添加顺序按照每个节点加入SPF树的顺序）∶</p>
<ol>
<li><p>1.1.1.1 ( RTA )的Router LSA中，共1个Stub连接，网络号&#x2F;掩码10.1.13.0&#x2F;24，Metric&#x3D;48;</p>
</li>
<li><p>10.1.12.2( DR)的Network LSA中，网络号&#x2F;掩码10.1.12.0&#x2F;24，Metric&#x3D;1+0&#x3D;1 ;</p>
</li>
<li><p>2.2.2.2 (RTB)的Router LSA中，共1个Stub连接，网络号&#x2F;掩码10.1.24.0&#x2F;24，Metric&#x3D;1+0+48&#x3D;49 ;</p>
</li>
<li><p>10.1.235.2 (DR)的Network LSA中，网络号&#x2F;掩码10.1.235.0&#x2F;24 ，Metric&#x3D;1+0+1&#x3D;2 ;</p>
</li>
<li><p>3.3.3.3 ( RTC )的Router LSA中，共1个Stub连接，网络号&#x2F;掩码10.1.13.0&#x2F;24，已在RTA上，忽略;</p>
</li>
<li><p>5.5.5.5 ( RTE )的Router LSA中，共1个Stub连接，网络号&#x2F;掩码10.1.45.0&#x2F;24，Metric&#x3D;1+O+0+1+48&#x3D;50 ;</p>
</li>
<li><p>4.4.4.4 ( RTD)的Router LSA中，共2个Stub连接，网络号&#x2F;掩码10.1.24.0&#x2F;24，已</p>
<p>在RTB上，忽略﹔网络号&#x2F;掩码10.1.45.0&#x2F;24，已在RTE上，忽略。</p>
</li>
</ol>
<p><img src="/../../images/OSPF/LSDBRouting.png"></p>
<p><u>注：不同的根节点生成的SPF树也是不同的</u></p>
<h2 id="区域间路由计算"><a href="#区域间路由计算" class="headerlink" title="区域间路由计算"></a>区域间路由计算</h2><h3 id="区域划分"><a href="#区域划分" class="headerlink" title="区域划分"></a>区域划分</h3><p><img src="/../../images/OSPF/%E5%8C%BA%E5%9F%9F%E5%88%92%E5%88%86.png"></p>
<ul>
<li><p>OSPF采用划分区域的方式，将一个大网络划分为多个相互连接的小网络。每个区域内的设备只需同步所在区域内的链路状态数据库，一定程度上降低内存及CPU的消耗。</p>
</li>
<li><p>划分区域后，根据路由器所连接区域的情况，可划分两种路由器角色︰</p>
<ol>
<li><p>区域内部路由器(Internal Router )︰该类设备的所有接口都属于同一个OSPF区域。</p>
</li>
<li><p>区域边界路由器(Area Border Router )∶该类设备接口分别连接两个及两个以上的不同区域。</p>
</li>
</ol>
</li>
<li><p>区域内部路由器维护本区域内的链路状态信息并计算区域内的最优路径。</p>
</li>
</ul>
<h3 id="区域间路由传递"><a href="#区域间路由传递" class="headerlink" title="区域间路由传递"></a>区域间路由传递</h3><p><img src="/../../images/OSPF/%E5%8C%BA%E5%9F%9F%E9%97%B4%E8%B7%AF%E7%94%B1%E4%BC%A0%E9%80%92.png"></p>
<ul>
<li>区域边界路由器作为区域间通信的桥梁，同时维护所连接多个区域的链路状态数据库。</li>
<li>ABR将一个区域内的链路状态信息转化成路由信息，然后发布到邻居区域。</li>
<li>链路状态信息转换成路由信息其实就是将一类和二类LSA转化成三类LSA的过程。注意，区域间的路由信息在ABR上是双向传递的。</li>
<li>192.168.1.0 网络在本区域以一类LSA进行传递，ABR RTB 负责将该一类LSA转换成三类LSA，并发送到Area 0；ABR RBC 又重新生成一份三类 LSA 发送到 Area 2</li>
</ul>
<h3 id="Summary-LSA（三类LSA）"><a href="#Summary-LSA（三类LSA）" class="headerlink" title="Summary LSA（三类LSA）"></a>Summary LSA（三类LSA）</h3><p><img src="/../../images/OSPF/%E4%B8%89%E7%B1%BBLSA.png"></p>
<p><u>记录对于本区域的非本区域网段</u></p>
<p><strong>对照表</strong></p>
<table>
<thead>
<tr>
<th align="center">LSA类型</th>
<th align="center">Ls id</th>
<th align="center">Adv rtr</th>
</tr>
</thead>
<tbody><tr>
<td align="center">router</td>
<td align="center">链路状态id（一般为router ID)</td>
<td align="center">产生此LSA路由器的router ID</td>
</tr>
<tr>
<td align="center">network</td>
<td align="center">DR 接口IP</td>
<td align="center">DR 的router ID</td>
</tr>
<tr>
<td align="center">summary</td>
<td align="center">目的网段IP</td>
<td align="center">产生此LSA路由器( 即ABR )的router ID</td>
</tr>
</tbody></table>
<p>示例：</p>
<p><img src="/../../images/OSPF/%E6%88%AA%E5%9B%BE1.png"></p>
<p>对于router 6 的summary LSA 有：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	         Area: 0.0.0.0</span><br><span class="line">Type      LinkState ID    AdvRouter          Age  Len   Sequence   Metric</span><br><span class="line">Sum-Net   10.1.67.0       6.6.6.6            124  28    80000001       1</span><br><span class="line">Sum-Net   10.1.16.0       6.6.6.6            124  28    80000001       1</span><br><span class="line">Sum-Net   10.1.16.0       1.1.1.1            163  28    80000001       1</span><br><span class="line">//由于R1和R6之间有一条虚拟连接，所以有两条sum LSA</span><br><span class="line"></span><br><span class="line">	         Area: 0.0.0.1</span><br><span class="line">Type      LinkState ID    AdvRouter          Age  Len   Sequence   Metric</span><br><span class="line">Sum-Net   10.1.45.0       1.1.1.1            124  28    80000003      50</span><br><span class="line">Sum-Net   10.1.13.0       1.1.1.1            161  28    80000001      48</span><br><span class="line">Sum-Net   10.1.24.0       1.1.1.1            124  28    80000002      49</span><br><span class="line">Sum-Net   10.1.12.0       1.1.1.1            164  28    80000001       1</span><br><span class="line">Sum-Net   10.1.235.0      1.1.1.1            124  28    80000002       2</span><br><span class="line">Sum-Net   10.1.67.0       6.6.6.6            124  28    80000001       1</span><br><span class="line">//Area1 有两个ABR</span><br><span class="line"></span><br><span class="line">	         Area: 0.0.0.2</span><br><span class="line">Type      LinkState ID    AdvRouter          Age  Len   Sequence   Metric</span><br><span class="line">Sum-Net   10.1.45.0       6.6.6.6            123  28    80000002      51</span><br><span class="line">Sum-Net   10.1.13.0       6.6.6.6            124  28    80000001      49</span><br><span class="line">Sum-Net   10.1.24.0       6.6.6.6            124  28    80000002      50</span><br><span class="line">Sum-Net   10.1.12.0       6.6.6.6            125  28    80000001       2</span><br><span class="line">Sum-Net   10.1.235.0      6.6.6.6            124  28    80000002       3</span><br><span class="line">Sum-Net   10.1.16.0       6.6.6.6            125  28    80000001       1</span><br></pre></td></tr></table></figure>

<h3 id="避免域间路由环路"><a href="#避免域间路由环路" class="headerlink" title="避免域间路由环路"></a>避免域间路由环路</h3><p>为防止区域间的环路OSPF定义了骨干区域和非骨干区域和三类LSA的传递规则</p>
<ul>
<li>OSPF划分了骨干区域和非骨干区域，<u>所有非骨干区域均直接和骨千区域相连，且骨干区域只有一个，非骨干区域之间的通信都要通过骨干区域中转，骨干区域ID固定为0。</u></li>
<li>OSPF规定从骨干区域传来的三类LSA不再传回骨干区域。</li>
</ul>
<p>新建网络按照区域间的防环规则进行部署，可以避免区域间环路问题。但是部分网络可能因早期规划问题，区域间的连接关系违背了骨干区域和非骨干区域的规则。</p>
<h3 id="虚拟链接"><a href="#虚拟链接" class="headerlink" title="虚拟链接"></a>虚拟链接</h3><p><img src="/../../images/OSPF/%E8%99%9A%E6%8B%9F%E9%93%BE%E6%8E%A5.png"></p>
<ul>
<li>骨干区域必须是连续的，但是并不要求物理上连续，可以使用虚连接使骨干区域逻辑上连续。</li>
<li>虚连接可以在任意两个区域边界路由器上建立，但是<u>要求这两个区域边界路由器都有端口连接到一个相同的非骨干区域。</u></li>
<li><strong>骨干区域不允许配置虚拟链接</strong></li>
<li><strong>跨越哪个区域就进入哪个区域配置虚拟连接</strong></li>
<li><strong>建立虚拟链接的不是接口ip，而是router ID</strong>（邻居）</li>
<li>如图所示，在RTB和RTC之间建立了一条虚连接，以使Area 2穿越Area1连接到骨干区域。</li>
</ul>
<h2 id="外部路由"><a href="#外部路由" class="headerlink" title="外部路由"></a>外部路由</h2><h3 id="外部路由计算"><a href="#外部路由计算" class="headerlink" title="外部路由计算"></a>外部路由计算</h3><p><img src="/../../images/OSPF/%E5%A4%96%E9%83%A8%E8%B7%AF%E7%94%B1demo.png"></p>
<p>在之前的实验基础上，AR10是外部路由，不做ospf协议，仅做基本的配置，和AR1做了双向的静态路由。</p>
<p>在AR1上将静态路由加入ospf协议中：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[Huawei]ospf 1</span><br><span class="line">[Huawei-ospf-1]import-route static ?</span><br><span class="line">  cost          Set cost</span><br><span class="line">  route-policy  Route policy</span><br><span class="line">  tag           Specify route tag</span><br><span class="line">  type          Metric type of the imported external routes</span><br><span class="line">  &lt;cr&gt;          Please press ENTER to execute command </span><br><span class="line">[Huawei-ospf-1]import-route static </span><br></pre></td></tr></table></figure>

<ul>
<li>在AR1的OSPF进程下，将配置的静态路由重发布到OSPF网络中，其中引入外部路由的OSPF路由器叫做ASBR（设备间互访需要路由双向可达，这里仅介绍OSPF网络内获取外部路由的过程）。</li>
<li>AR1会生成一条**<u>AS-External-LSA(五类LSA)</u><strong>，用于描述如何从ASBR（Autonomous System Boundary Router 自治系统边界路由器）到达外部目的地；AR6会生成一条</strong><u>ASBR-Summary-LSA(四类LSA)</u>**，用于描述如何从ABR到达ASBR。</li>
<li>四类LSA和五类LSA，将被OSPF路由器用来计算外部路由。</li>
</ul>
<h4 id="AS-External-LSA"><a href="#AS-External-LSA" class="headerlink" title="AS External LSA"></a>AS External LSA</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[AR1]dis ospf lsdb</span><br><span class="line"></span><br><span class="line">	 OSPF Process 1 with Router ID 1.1.1.1</span><br><span class="line">		 Link State Database </span><br><span class="line"> </span><br><span class="line"> //已忽略其他区域</span><br><span class="line"> </span><br><span class="line">		 AS External Database</span><br><span class="line"> Type      LinkState ID    AdvRouter          Age  Len   Sequence   Metric</span><br><span class="line"> External  114.114.114.0   1.1.1.1             26  36    80000001       1</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;AR1&gt;dis ospf lsdb ase self-originate </span><br><span class="line"></span><br><span class="line">	 OSPF Process 1 with Router ID 1.1.1.1</span><br><span class="line">		 Link State Database</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  Type      : External                   //LSA类型</span><br><span class="line">  Ls id     : 114.114.114.0				//目的网段</span><br><span class="line">  Adv rtr   : 1.1.1.1  					//产生此五类LSA ASBR的router ID</span><br><span class="line">  Ls age    : 1706 </span><br><span class="line">  Len       : 36 </span><br><span class="line">  Options   :  E  </span><br><span class="line">  seq#      : 80000003 </span><br><span class="line">  chksum    : 0xc4ae</span><br><span class="line">  Net mask  : 255.255.255.0 			//掩码</span><br><span class="line">  TOS 0  Metric: 1 					    //开销值</span><br><span class="line">  E type    : 2</span><br><span class="line">  Forwarding Address : 0.0.0.0 </span><br><span class="line">  Tag       : 1 						//Tag:外部路由信息可以携带一个Tag标签，用于传递该路由的附加信	   Priority  : Low						 //息，通常用于路由策略，默认值为1。</span><br></pre></td></tr></table></figure>



<h4 id="ASBR-Summary-LSA"><a href="#ASBR-Summary-LSA" class="headerlink" title="ASBR Summary LSA"></a>ASBR Summary LSA</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[AR1]dis ospf lsdb</span><br><span class="line"></span><br><span class="line">	 OSPF Process 1 with Router ID 1.1.1.1</span><br><span class="line">		 Link State Database </span><br><span class="line"></span><br><span class="line">		         Area: 0.0.0.0</span><br><span class="line"> Type      LinkState ID    AdvRouter          Age  Len   Sequence   Metric</span><br><span class="line"> Sum-Asbr  1.1.1.1         6.6.6.6             26  28    80000001       1</span><br><span class="line"> </span><br><span class="line">		         Area: 0.0.0.1</span><br><span class="line"> Type      LinkState ID    AdvRouter          Age  Len   Sequence   Metric</span><br><span class="line"> Sum-Asbr  1.1.1.1         6.6.6.6             26  28    80000001       1</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;AR1&gt;dis ospf lsdb asbr </span><br><span class="line"></span><br><span class="line">	 OSPF Process 1 with Router ID 1.1.1.1</span><br><span class="line">		         Area: 0.0.0.0</span><br><span class="line">		 Link State Database </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  Type      : Sum-Asbr</span><br><span class="line">  Ls id     : 1.1.1.1						//LSA类型</span><br><span class="line">  Adv rtr   : 6.6.6.6  						//ASBR的router ID</span><br><span class="line">  Ls age    : 483 							//产生此四类LSA ABR的router ID</span><br><span class="line">  Len       : 28 </span><br><span class="line">  Options   :  E  </span><br><span class="line">  seq#      : 80000004 </span><br><span class="line">  chksum    : 0x7ebd</span><br><span class="line">  Tos 0  metric: 1							//从此ABR到ASBR的开销</span><br><span class="line">		         Area: 0.0.0.1				//AR1即是area 0 的ABR又是area 1的ABR</span><br><span class="line">		 Link State Database </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  Type      : Sum-Asbr</span><br><span class="line">  Ls id     : 1.1.1.1</span><br><span class="line">  Adv rtr   : 6.6.6.6  </span><br><span class="line">  Ls age    : 483 </span><br><span class="line">  Len       : 28 </span><br><span class="line">  Options   :  E  </span><br><span class="line">  seq#      : 80000004 </span><br><span class="line">  chksum    : 0x7ebd</span><br><span class="line">  Tos 0  metric: 1</span><br></pre></td></tr></table></figure>

<ul>
<li>四类LSA只能在一个区域内泛洪，五类LSA每泛洪到一个区域，相应区域的ABR都会生成一条新的四类LSA来描述如何到达ASBR。</li>
<li>因此描述到达同一个ASBR的四类LSA可以有多条，其Adv rtr是不同的，表示是由不同的ABR生成的。</li>
</ul>
<h3 id="外部路由类型"><a href="#外部路由类型" class="headerlink" title="外部路由类型"></a>外部路由类型</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;AR7&gt;dis ip routing-table </span><br><span class="line">Route Flags: R - relay, D - download to fib</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">Routing Tables: Public</span><br><span class="line">         Destinations : 15       Routes : 15       </span><br><span class="line"></span><br><span class="line">Destination/Mask    Proto   Pre  Cost      Flags NextHop         Interface</span><br><span class="line"></span><br><span class="line">      10.1.12.0/24  OSPF    10   3           D   10.1.67.6       GigabitEthernet</span><br><span class="line">0/0/0</span><br><span class="line">      10.1.13.0/24  OSPF    10   50          D   10.1.67.6       GigabitEthernet</span><br><span class="line">0/0/0</span><br><span class="line">      10.1.16.0/24  OSPF    10   2           D   10.1.67.6       GigabitEthernet</span><br><span class="line">0/0/0</span><br><span class="line">      10.1.24.0/24  OSPF    10   51          D   10.1.67.6       GigabitEthernet</span><br><span class="line">0/0/0</span><br><span class="line">      10.1.45.0/24  OSPF    10   52          D   10.1.67.6       GigabitEthernet</span><br><span class="line">0/0/0</span><br><span class="line">      10.1.67.0/24  Direct  0    0           D   10.1.67.7       GigabitEthernet</span><br><span class="line">0/0/0</span><br><span class="line">      10.1.67.7/32  Direct  0    0           D   127.0.0.1       GigabitEthernet</span><br><span class="line">0/0/0</span><br><span class="line">    10.1.67.255/32  Direct  0    0           D   127.0.0.1       GigabitEthernet</span><br><span class="line">0/0/0</span><br><span class="line">     10.1.113.0/24  OSPF    10   5           D   10.1.67.6       GigabitEthernet</span><br><span class="line">0/0/0</span><br><span class="line">     10.1.235.0/24  OSPF    10   4           D   10.1.67.6       GigabitEthernet</span><br><span class="line">0/0/0</span><br><span class="line">  114.114.114.0/24  O_ASE   150  1           D   10.1.67.6       GigabitEthernet</span><br><span class="line">0/0/0</span><br><span class="line">      127.0.0.0/8   Direct  0    0           D   127.0.0.1       InLoopBack0</span><br><span class="line">      127.0.0.1/32  Direct  0    0           D   127.0.0.1       InLoopBack0</span><br><span class="line">127.255.255.255/32  Direct  0    0           D   127.0.0.1       InLoopBack0</span><br><span class="line">255.255.255.255/32  Direct  0    0           D   127.0.0.1       InLoopBack0</span><br></pre></td></tr></table></figure>

<p>在AR7上查看路由表，发现到外部114.114.114.0网段的开销为1，而从图片上看很明显不为1</p>
<table>
<thead>
<tr>
<th align="center">Type</th>
<th align="center">Cost</th>
</tr>
</thead>
<tbody><tr>
<td align="center">第一类外部路由（External Type 1）</td>
<td align="center">AS 内部开销值 + AS 外部开销值</td>
</tr>
<tr>
<td align="center">第二类外部路由（External Type 2）</td>
<td align="center">AS外部开销值</td>
</tr>
</tbody></table>
<ul>
<li><p>OSPF引入外部路由，共有两种类型可选：</p>
<ol>
<li><p>第一类外部路由的AS外部开销值被认为和AS内部开销值是同一数量级的，因此第一类外部路由的开销值为AS内部开销值（路由器到ASBR的开销）与AS外部开销值之和;这类路由的可信程度高一些，所以计算出的外部路由的开销与自治系统内部的路由开销是相当的，并且和OSPF自身路由的开销具有可比性。</p>
</li>
<li><p>第二类外部路由的AS外部开销值被认为远大于AS内部开销值，因此第二类外部路由<br>的开销值只包含AS外部开销，忽略AS内部开销（默认为第二类），这类路由的可信度比较低。</p>
</li>
</ol>
</li>
<li><p>默认情况下，OSPF外部路由采用的是第二类外部路由。</p>
</li>
</ul>
<h3 id="次优外部路由的产生"><a href="#次优外部路由的产生" class="headerlink" title="次优外部路由的产生"></a>次优外部路由的产生</h3><p><img src="/../../images/OSPF/%E6%AC%A1%E4%BC%98%E5%A4%96%E9%83%A8%E8%B7%AF%E7%94%B11.png"></p>
<ol>
<li>RTA 和 RTB 运行OSPF协议，RTB 和 RTC 运行RIP协议</li>
<li>RTB 把通过 RIP 学来的协议发布到OSPF中，RTA 通过OSPF学到了到192.168.3.0网段的路由，但是下一跳为RTB，这一条路径在 RTA 上是次优的，最优的下一跳应该是 RTC 的10.1.123.3接口</li>
<li>OSPF 通过设置 Forwarding Address 来解决这个问题</li>
</ol>
<p><img src="/../../images/OSPF/%E6%AC%A1%E4%BC%98%E5%A4%96%E9%83%A8%E8%B7%AF%E7%94%B12.png"></p>
<ul>
<li>通常情况下，ASBR引入外部路由产生的五类LSA中Forwarding Address字段设置为0.0.0.0。</li>
<li>对于图中的场景，RTB路由表中到达192.168.3.0&#x2F;24的下一跳地址为10.1.123.3。</li>
<li>10.1.123.3 所属网段 10.1.123.0&#x2F;24 运行OSPF，所以RTB生成的五类LSA中，ForwardingAddress被设置为10.1.123.3。</li>
<li>当RTA收到五类LSA时，发现Forwarding Address字段非0，其值为10.1.123.3，所以RTA按照Forwarding Address计算下一跳</li>
</ul>
<h1 id="OSPF特殊区域及其他特性"><a href="#OSPF特殊区域及其他特性" class="headerlink" title="OSPF特殊区域及其他特性"></a>OSPF特殊区域及其他特性</h1><h2 id="Stub区域和Totally-Stub区域"><a href="#Stub区域和Totally-Stub区域" class="headerlink" title="Stub区域和Totally Stub区域"></a>Stub区域和Totally Stub区域</h2><h3 id="传输区域和末端区域"><a href="#传输区域和末端区域" class="headerlink" title="传输区域和末端区域"></a>传输区域和末端区域</h3><p><img src="/../../images/OSPF/%E4%BC%A0%E8%BE%93%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%9C%AB%E7%AB%AF%E5%8C%BA%E5%9F%9F.png"></p>
<p>如图所示，全网可分为四部分Area 0、Area 1、Area 2、外部网络。四部分之间相互访问的主要流量如图中红线所示。</p>
<p>对于OSPF各区域，可分为两种类型∶</p>
<ul>
<li>传输区域︰除了承载本区域反也的流!以，如Area 0。IP都不属于本区域的流量，即“穿越型流量”，如Area 0。</li>
<li>末端区域:只承载本区域发起的流量和访问本区域的流量，如Area 1。</li>
</ul>
<p>对于末端区域，需要考虑下几个问题:</p>
<ul>
<li>保存到达其他区域明细路由的必要性∶访问其他区域通过单一出口，“汇总”路由相对明细路由更为简洁。</li>
<li>设备性能︰网络建设与维护必须要考虑成本因素。末端区域中可选择部署性能相对较低的路由器。</li>
</ul>
<p>OSPF路由器计算区域内、区域间、外部路由都需要依靠收集网络中的大量LSA，大量LSA会占用LSDB存储空间，所以解决问题的关键是在不影响正常路由的情况下，减少LSA的数量。</p>
<h3 id="Stub区域"><a href="#Stub区域" class="headerlink" title="Stub区域"></a>Stub区域</h3><p><img src="/../../images/OSPF/Stub%E5%8C%BA%E5%9F%9F.png"></p>
<p>Stub区域的ABR不向Stub区域内传播它接收到的自治系统外部路由（对应四类、五类LSA )，Stub区域中路由器的LSDB、路由表规模都会大大减小。</p>
<p>为保证Stub区域能够到达自治系统外部，<u>Stub区域的ABR将生成一条缺省路由（对应三类LSA )</u>，并发布给Stub区域中的其他路由器。</p>
<p>Stub区域是一种可选的配置属性，但并不建议将每个区域都配置为Stub区域。通常来说，Stub区域位于自治系统的末梢，是那些只有一个ABR的非骨干区域。</p>
<p>配置Stub区域时需要注意下列几点︰</p>
<ul>
<li>骨干区域不能被配置为Stub区域。</li>
<li><u>如果要将一个区域配置成Stub区域，则<strong>该区域中的所有路由器必须都要配置成Stub路由器</strong>。</u></li>
<li>Stub区域内不能存在ASBR，自治系统外部路由不能在本区域内传播。</li>
<li><u>虚连接不能穿越Stub区域建立</u>。</li>
</ul>
<p><img src="/../../images/OSPF/Stub%E5%8C%BA%E5%9F%9Fdemo.png"></p>
<p>AR4 设置Stub之前的LSDB：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;AR4&gt;dis ospf lsdb</span><br><span class="line"></span><br><span class="line">	 OSPF Process 1 with Router ID 4.4.4.4</span><br><span class="line">		 Link State Database </span><br><span class="line"></span><br><span class="line">		         Area: 0.0.0.1</span><br><span class="line"> Type      LinkState ID    AdvRouter          Age  Len   Sequence   Metric</span><br><span class="line"> Router    4.4.4.4         4.4.4.4            242  36    80000003       1</span><br><span class="line"> Router    2.2.2.2         2.2.2.2            240  36    80000005       1</span><br><span class="line"> Network   10.1.24.2       2.2.2.2            241  32    80000002       0</span><br><span class="line"> Sum-Net   10.1.35.0       2.2.2.2            114  28    80000001       3</span><br><span class="line"> Sum-Net   10.1.13.0       2.2.2.2            282  28    80000001       2</span><br><span class="line"> Sum-Net   10.1.12.0       2.2.2.2            282  28    80000001       1</span><br></pre></td></tr></table></figure>

<p>只给AR4设置Stub后：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[AR4]ospf 1</span><br><span class="line">[AR4-ospf-1]area 1</span><br><span class="line">[AR4-ospf-1-area-0.0.0.1]stub </span><br><span class="line">&lt;AR4&gt;dis ospf lsdb</span><br><span class="line"></span><br><span class="line">	 OSPF Process 1 with Router ID 4.4.4.4</span><br><span class="line">		 Link State Database </span><br><span class="line"></span><br><span class="line">		         Area: 0.0.0.1</span><br><span class="line"> Type      LinkState ID    AdvRouter          Age  Len   Sequence   Metric</span><br><span class="line"> Router    4.4.4.4         4.4.4.4             15  36    80000001       1</span><br></pre></td></tr></table></figure>

<p>给AR2设置Stub后，AR4的LSDB变化</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[AR2]ospf 1</span><br><span class="line">[AR2-ospf-1]area 1</span><br><span class="line">[AR2-ospf-1-area-0.0.0.1]stub </span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------</span><br><span class="line"></span><br><span class="line">&lt;AR4&gt;dis ospf lsdb</span><br><span class="line"></span><br><span class="line">	 OSPF Process 1 with Router ID 4.4.4.4</span><br><span class="line">		 Link State Database </span><br><span class="line"></span><br><span class="line">		         Area: 0.0.0.1</span><br><span class="line"> Type      LinkState ID    AdvRouter          Age  Len   Sequence   Metric</span><br><span class="line"> Router    4.4.4.4         4.4.4.4              1  36    80000003       1</span><br><span class="line"> Router    2.2.2.2         2.2.2.2              1  36    80000003       1</span><br><span class="line"> Network   10.1.24.4       4.4.4.4              0  32    80000001       0</span><br><span class="line"> Sum-Net   0.0.0.0         2.2.2.2              8  28    80000001       1     //多了一条缺省LSA</span><br><span class="line"> Sum-Net   10.1.35.0       2.2.2.2              8  28    80000001       3</span><br><span class="line"> Sum-Net   10.1.13.0       2.2.2.2              8  28    80000001       2</span><br><span class="line"> Sum-Net   10.1.12.0       2.2.2.2              8  28    80000001       1</span><br><span class="line"> </span><br><span class="line"> &lt;AR4&gt;dis ospf routing </span><br><span class="line"></span><br><span class="line">	 OSPF Process 1 with Router ID 4.4.4.4</span><br><span class="line">		  Routing Tables </span><br><span class="line"></span><br><span class="line"> Routing for Network </span><br><span class="line"> Destination        Cost  Type       NextHop         AdvRouter       Area</span><br><span class="line"> 10.1.24.0/24       1     Transit    10.1.24.4       4.4.4.4         0.0.0.1</span><br><span class="line"> 0.0.0.0/0          2     Inter-area 10.1.24.2       2.2.2.2         0.0.0.1    //多了一条缺省路由</span><br><span class="line"> 10.1.12.0/24       2     Inter-area 10.1.24.2       2.2.2.2         0.0.0.1</span><br><span class="line"> 10.1.13.0/24       3     Inter-area 10.1.24.2       2.2.2.2         0.0.0.1</span><br><span class="line"> 10.1.35.0/24       4     Inter-area 10.1.24.2       2.2.2.2         0.0.0.1</span><br><span class="line"></span><br><span class="line"> Total Nets: 5  </span><br><span class="line"> Intra Area: 1  Inter Area: 4  ASE: 0  NSSA: 0 </span><br></pre></td></tr></table></figure>

<ul>
<li>配置Stub区域后，所有自治系统外部路由均由一条三类的默认路由代替。</li>
<li>除路由条目的减少外，当外部网络发生变化后，Stub区域内的路由器是不会直接受到影响的。</li>
</ul>
<h3 id="Totally-Stub区域"><a href="#Totally-Stub区域" class="headerlink" title="Totally Stub区域"></a>Totally Stub区域</h3><p>![](..&#x2F;..&#x2F;images&#x2F;OSPF&#x2F;Totally Stub区域.png)</p>
<ul>
<li>Totally Stub区域既不允许自治系统外部路由（四类、五类LSA)在本区域内传播，也不允许区域间路由（三类LSA)在本区域内传播。</li>
<li>Totally Stub区域内的路由器对其他区域及自制系统外部的访问需求是通过本区域ABR所产生的三类LSA缺省路由实现的。</li>
<li>与Stub区域配置的区别在于，在ABR上需要追加no-summary参数</li>
</ul>
<p>在AR2 设置及变化：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[AR2]ospf 1</span><br><span class="line">[AR2-ospf-1]area 1</span><br><span class="line">[AR2-ospf-1-area-0.0.0.1]stub no-summary </span><br><span class="line"></span><br><span class="line">&lt;AR2&gt;dis ospf lsdb</span><br><span class="line"></span><br><span class="line">	 OSPF Process 1 with Router ID 2.2.2.2</span><br><span class="line">		 Link State Database </span><br><span class="line"></span><br><span class="line">                  //已忽略 Area 0</span><br><span class="line"> </span><br><span class="line">		         Area: 0.0.0.1</span><br><span class="line"> Type      LinkState ID    AdvRouter          Age  Len   Sequence   Metric</span><br><span class="line"> Router    4.4.4.4         4.4.4.4            106  36    80000009       1</span><br><span class="line"> Router    2.2.2.2         2.2.2.2            113  36    80000005       1</span><br><span class="line"> Network   10.1.24.4       4.4.4.4            106  32    80000002       0</span><br><span class="line"> Sum-Net   0.0.0.0         2.2.2.2            124  28    80000001       1      //缺省</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> &lt;AR2&gt;dis ospf routing </span><br><span class="line"></span><br><span class="line">	 OSPF Process 1 with Router ID 2.2.2.2</span><br><span class="line">		  Routing Tables </span><br><span class="line"></span><br><span class="line"> Routing for Network </span><br><span class="line"> Destination        Cost  Type       NextHop         AdvRouter       Area</span><br><span class="line"> 10.1.12.0/24       1     Transit    10.1.12.2       2.2.2.2         0.0.0.0</span><br><span class="line"> 10.1.24.0/24       1     Transit    10.1.24.2       2.2.2.2         0.0.0.1</span><br><span class="line"> 10.1.13.0/24       2     Transit    10.1.12.1       1.1.1.1         0.0.0.0</span><br><span class="line"> 10.1.35.0/24       3     Inter-area 10.1.12.1       3.3.3.3         0.0.0.0</span><br><span class="line"></span><br><span class="line"> Total Nets: 4  </span><br><span class="line"> Intra Area: 3  Inter Area: 1  ASE: 0  NSSA: 0 </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>AR4的变化：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;AR4&gt;dis ospf lsdb</span><br><span class="line"></span><br><span class="line">	 OSPF Process 1 with Router ID 4.4.4.4</span><br><span class="line">		 Link State Database </span><br><span class="line"></span><br><span class="line">		         Area: 0.0.0.1</span><br><span class="line"> Type      LinkState ID    AdvRouter          Age  Len   Sequence   Metric</span><br><span class="line"> Router    4.4.4.4         4.4.4.4            207  36    80000009       1</span><br><span class="line"> Router    2.2.2.2         2.2.2.2            217  36    80000005       1</span><br><span class="line"> Network   10.1.24.4       4.4.4.4            207  32    80000002       0</span><br><span class="line"> Sum-Net   0.0.0.0         2.2.2.2            228  28    80000001       1     //缺省</span><br><span class="line"> </span><br><span class="line">&lt;AR4&gt;dis ospf routing</span><br><span class="line"></span><br><span class="line">	 OSPF Process 1 with Router ID 4.4.4.4</span><br><span class="line">		  Routing Tables </span><br><span class="line"></span><br><span class="line"> Routing for Network </span><br><span class="line"> Destination        Cost  Type       NextHop         AdvRouter       Area</span><br><span class="line"> 10.1.24.0/24       1     Transit    10.1.24.4       4.4.4.4         0.0.0.1</span><br><span class="line"> 0.0.0.0/0          2     Inter-area 10.1.24.2       2.2.2.2         0.0.0.1   //缺省</span><br><span class="line"></span><br><span class="line"> Total Nets: 2  </span><br><span class="line"> Intra Area: 1  Inter Area: 1  ASE: 0  NSSA: 0 </span><br></pre></td></tr></table></figure>

<ul>
<li>Totally Stub区域访问其他区域及自制系统外部是通过默认路由实现的。</li>
<li>自制系统外部、其他OSPF区域的网络发生变化，Totally Stub区域内的路由器是不直接受影响的。</li>
<li>Stub、Totally Stub解决了末端区域维护过大LSDB带来的问题，但对于某些特定场景Stub、Totally Stub并不是最佳解决方案。</li>
</ul>
<table>
<thead>
<tr>
<th align="center">区域</th>
<th align="center">区域内路由的LSDB</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Stub</td>
<td align="center">一、二、三类LSA以及一条缺省三类LSA</td>
</tr>
<tr>
<td align="center">Totally Stub</td>
<td align="center">一、二类LSA以及一条缺省三类LSA</td>
</tr>
</tbody></table>
<h2 id="NSSA区域和Totally-NSSA区域"><a href="#NSSA区域和Totally-NSSA区域" class="headerlink" title="NSSA区域和Totally NSSA区域"></a>NSSA区域和Totally NSSA区域</h2><p><img src="/../../images/OSPF/NSSA%E5%8C%BA%E5%9F%9F.png"></p>
<p>OSPF NSSA区域(Not-So-Stubby Area)是在原始OSPF协议标准中新增的一类特殊区域类型。</p>
<p>NSSA区域和Stub区域有许多相似的地方。两者的差别在于，<u>NSSA区域能够将自治域外部路由引入并传播到整个OSPF自治域中，同时又不会学习来自OSPF网络其它区域的外部路由</u>。</p>
<p>NSSA LSA(七类LSA ) :</p>
<ul>
<li><p>七类LSA是为了支持NSSA区域而新增的一种LSA类型，用于描述NSSA区域引入的外部路由信息。</p>
</li>
<li><p>七类LSA由NSSA区域的ASBR产生，其扩散范围仅限于ASBR所在的NSSA区域。</p>
</li>
<li><p>缺省路由也可以通过七类LSA来产生，用于指导流量流向其它自治域。</p>
</li>
</ul>
<p>七类LSA转换为五类LSA:</p>
<ul>
<li>.NSSA区域的ABR收到七类LSA时，会有选择地将其转换为五类LSA，以便将外部路由信息通告到OSPF网络的其它区域。</li>
<li>NSSA区域有多个ABR时，进行7类LSA与5类LSA转换的是Router ID最大的ABR。</li>
</ul>
<p>Totally NSSA和NSSA区别∶</p>
<ul>
<li>Totally NSSA不允许三类LSA在本区域内泛洪。</li>
<li>Totally NSSA与NSSA区域的配置区别在于ABR上需要追加no-summary参数。</li>
</ul>
<table>
<thead>
<tr>
<th align="center">LSA类型</th>
<th align="center">通告路由</th>
<th align="center">LSA内容</th>
<th align="center">传播范围</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Router LSA（一）</td>
<td align="center">OSPF Router</td>
<td align="center">拓扑信息+路由信息</td>
<td align="center">本区域内</td>
</tr>
<tr>
<td align="center">Network LSA（二）</td>
<td align="center">DR</td>
<td align="center">拓扑信息+路由信息</td>
<td align="center">本区域内</td>
</tr>
<tr>
<td align="center">Network Summer LSA（三）</td>
<td align="center">ABR</td>
<td align="center">域间路由信息</td>
<td align="center">非（Totally）Stub区域</td>
</tr>
<tr>
<td align="center">ASBR Summary LSA（四）</td>
<td align="center">ABR</td>
<td align="center">ASBR 的Router ID</td>
<td align="center">非（Totally）Stub区域</td>
</tr>
<tr>
<td align="center">AS external LSA（五）</td>
<td align="center">ASBR</td>
<td align="center">路由进程域外部路由</td>
<td align="center">（非Stub区域）OSPF进程区域</td>
</tr>
<tr>
<td align="center">NSSA LSA（七）</td>
<td align="center">ASBR</td>
<td align="center">NSSA域外部路由信息</td>
<td align="center">（Totally）NSSA区域</td>
</tr>
</tbody></table>
<p>LSA作用∶</p>
<ul>
<li>Router LSA （一类）：每个路由器都会产生，描述了路由器的链路状态和开销，在所属的区域内传播。</li>
<li>oNetwork LSA（二类）：由DR产生，描述本网段的链路状态，在所属的区域内传播。</li>
<li>Network-summary-LSA（三类）︰由ABR产生，描述区域内某个网段的路由，并通告给其他相关区域。</li>
<li>ASBR-summary-LSA（四类）：由ABR产生，描述到ASBR的路由，通告给除ASBR所在区域的其他相关区域。</li>
<li>AS-external-LSA（五类）：由ASBR产生，描述到AS外部的路由，<u>通告到所有的区域(除了Stub区域和NSSA区域)</u>。</li>
<li>NSSA LSA（七类）：由ASBR产生，描述到AS外部的路由，<u>仅在NSSA区域内传播</u>。</li>
</ul>
<h3 id="Nssa"><a href="#Nssa" class="headerlink" title="Nssa"></a>Nssa</h3><p>![](..&#x2F;..&#x2F;images&#x2F;OSPF&#x2F;nssa demo.png)</p>
<p>配置静态路由</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AR6</span><br><span class="line">[AR6]ip route-static 10.1.0.0 16 10.1.16.1</span><br><span class="line">[AR6]ip route-static 10.1.0.0 16 10.1.56.5</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AR5</span><br><span class="line">[AR5]ip route-static 6.6.6.0 24 10.1.56.6</span><br><span class="line">[AR5]ospf 1</span><br><span class="line">[AR5-ospf-1]import-route static </span><br><span class="line">[AR5-ospf-1]a 2</span><br><span class="line">[AR5-ospf-1-area-0.0.0.2]nssa</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AR3</span><br><span class="line">[AR3]ospf 1</span><br><span class="line">[AR3-ospf-1] a 2</span><br><span class="line">[AR3-ospf-1-area-0.0.0.2]nssa </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AR1</span><br><span class="line">[AR1]ip route-static 6.6.6.0 24 10.1.16.6</span><br><span class="line">[AR1]ospf 1</span><br><span class="line">[AR1-ospf-1]import-route static </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;AR5&gt;dis ospf lsdb </span><br><span class="line"></span><br><span class="line">	 OSPF Process 1 with Router ID 5.5.5.5</span><br><span class="line">		 Link State Database </span><br><span class="line"></span><br><span class="line">		         Area: 0.0.0.2</span><br><span class="line"> Type      LinkState ID    AdvRouter          Age  Len   Sequence   Metric</span><br><span class="line"> Router    5.5.5.5         5.5.5.5           1415  36    8000000C       1</span><br><span class="line"> Router    3.3.3.3         3.3.3.3           1417  36    80000004       1</span><br><span class="line"> Network   10.1.35.3       3.3.3.3           1417  32    80000001       0</span><br><span class="line"> Sum-Net   10.1.13.0       3.3.3.3             75  28    80000002       1</span><br><span class="line"> Sum-Net   10.1.24.0       3.3.3.3             30  28    80000002       3</span><br><span class="line"> Sum-Net   10.1.12.0       3.3.3.3             30  28    80000002       2</span><br><span class="line"> NSSA      6.6.6.0         5.5.5.5           1425  36    80000001       1  //由于引入了静态路由而产生</span><br><span class="line"> NSSA      0.0.0.0         3.3.3.3             37  36    80000002       1  //七类缺省</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;AR3&gt;dis ospf lsdb</span><br><span class="line"></span><br><span class="line">	 OSPF Process 1 with Router ID 3.3.3.3</span><br><span class="line">		 Link State Database </span><br><span class="line"></span><br><span class="line">                 //已忽略area 0</span><br><span class="line"></span><br><span class="line">		         Area: 0.0.0.2</span><br><span class="line"> Type      LinkState ID    AdvRouter          Age  Len   Sequence   Metric</span><br><span class="line"> Router    5.5.5.5         5.5.5.5            401  36    8000000D       1</span><br><span class="line"> Router    3.3.3.3         3.3.3.3            400  36    80000005       1</span><br><span class="line"> Network   10.1.35.3       3.3.3.3            400  32    80000002       0</span><br><span class="line"> Sum-Net   10.1.13.0       3.3.3.3            859  28    80000002       1</span><br><span class="line"> Sum-Net   10.1.24.0       3.3.3.3            814  28    80000002       3</span><br><span class="line"> Sum-Net   10.1.12.0       3.3.3.3            814  28    80000002       2</span><br><span class="line"> NSSA      0.0.0.0         3.3.3.3            821  36    80000002       1</span><br><span class="line"> NSSA      6.6.6.0         5.5.5.5            411  36    80000002       1</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">		 AS External Database</span><br><span class="line"> Type      LinkState ID    AdvRouter          Age  Len   Sequence   Metric</span><br><span class="line"> External  6.6.6.0         3.3.3.3            399  36    80000002       1</span><br><span class="line"> External  6.6.6.0         1.1.1.1             97  36    80000002       1</span><br><span class="line">//在区域2内，AR3 是ABR，将七类LSA转化为了五类LSA</span><br></pre></td></tr></table></figure>

<h3 id="Totally-Nssa"><a href="#Totally-Nssa" class="headerlink" title="Totally Nssa"></a>Totally Nssa</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AR3</span><br><span class="line">[AR3]ospf 1</span><br><span class="line">[AR3-ospf-1]a 2</span><br><span class="line">[AR3-ospf-1-area-0.0.0.2]nssa no-summary</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;AR5&gt;dis ospf lsdb</span><br><span class="line"></span><br><span class="line">	 OSPF Process 1 with Router ID 5.5.5.5</span><br><span class="line">		 Link State Database </span><br><span class="line"></span><br><span class="line">		         Area: 0.0.0.2</span><br><span class="line"> Type      LinkState ID    AdvRouter          Age  Len   Sequence   Metric</span><br><span class="line"> Router    5.5.5.5         5.5.5.5              5  36    80000012       1</span><br><span class="line"> Router    3.3.3.3         3.3.3.3             10  36    80000006       1</span><br><span class="line"> Network   10.1.35.5       5.5.5.5              5  32    80000002       0</span><br><span class="line"> Sum-Net   0.0.0.0         3.3.3.3             16  28    80000001       1  //只剩一条缺省三类LSA</span><br><span class="line"> NSSA      6.6.6.0         5.5.5.5           1660  36    80000002       1</span><br><span class="line"> NSSA      0.0.0.0         3.3.3.3             12  36    80000004       1</span><br></pre></td></tr></table></figure>



<h2 id="区域间路由汇总和外部路由汇总"><a href="#区域间路由汇总和外部路由汇总" class="headerlink" title="区域间路由汇总和外部路由汇总"></a>区域间路由汇总和外部路由汇总</h2><p><img src="/../../images/OSPF/%E5%8C%BA%E5%9F%9F%E9%97%B4%E8%B7%AF%E7%94%B1%E6%B1%87%E6%80%BB.png"></p>
<p>在大规模部署OSPF网络时，可能会出现由于OSPF路由表规模过大而降低路由查找速度的现象，为了解决这个问题，可以配置路由汇总，减小路由表的规模。</p>
<p><u>路由汇总是指将多条连续的IP前缀汇总成一条路由前缀</u>。如果被汇总的IP地址范围内的某条链路频繁Up和Down，该变化并不会通告给被汇总的IP地址范围外的设备。因此，可以避免网络中的路由振荡，在一定程度上提高了网络的稳定性。</p>
<p>路由汇总只能汇总路由信息，所以ABR是可以执行路由汇总的位置之一：<br>ABR向其它区域发送路由信息时，以网段为单位生成三类LSA。如果该区域中存在一些连续的网段，则可以通过命令将这些连续的网段汇总成一个网段。这样ABR只发送一条汇总后的三类LSA，所有属于命令指定的汇总网段范围的LSA将不会再被单独发送出去。</p>
<p>如图所示，Area 1中存在8个连续网段，汇总前RTB将产生8条三类LSA。在RTB上配置汇总后，RTB仅产生1条三类LSA并泛洪到Area 0。</p>
<p>引入外部路由的ASBR也是执行路由汇总的位置之一。</p>
<p><img src="/../../images/OSPF/%E5%A4%96%E9%83%A8%E8%B7%AF%E7%94%B1%E6%B1%87%E6%80%BB.png"></p>
<p>ASBR汇总∶</p>
<ul>
<li>配置ASBR汇总后，ASBR将对引入的外部路由进行汇总。NSSA区域的ASBR也可以对引入NSSA区域的外部路由进行汇总。</li>
<li>如果设备既是NSAA区域的ASBR又是ABR，则可在将七类LSA转换成五类LSA时对相应前缀进行汇总。</li>
</ul>
<p>如图所示，Area 0中RTA将8个连续的外部路由引入到OSPF域内，产生8条五类LSA并在OSPF进程域内泛洪。</p>
<p>在ASBR ( RTA)配置外部路由汇总后，RTA将仅产生1条五类LSA并泛洪至OSPF路由进程域内。</p>
<p>路由汇总降低了网络故障的影响范围。</p>
<p>网络发生故障后，路由协议的收敛速度也是衡量路由协议的重要参考依据之一。</p>
<h2 id="OSPF更新机制"><a href="#OSPF更新机制" class="headerlink" title="OSPF更新机制"></a>OSPF更新机制</h2><p><img src="/../../images/OSPF/%E5%AE%9A%E6%9C%9F%E6%9B%B4%E6%96%B0%E4%B8%8E%E8%A7%A6%E5%8F%91%E6%9B%B4%E6%96%B0.png"></p>
<p>为了保证路由计算的准确性，需要保证LSA的可靠性。</p>
<p>OSPF为每个LSA条目维持一个老化计时器(3600s )，当计时器超时，此LSA将从LSDB中删除。</p>
<p>为了防止LSA条目达到最大生存时间而被删除，OSPF通过定期更新（每1800s刷新一次)机制来刷新LSA。</p>
<p>OSPF路由器每1800s会重新生成LSA，并通告给其他路由器。为了加快收敛速度，OSPF设置了触发更新机制。</p>
<p>当链路状态发生变化后，路由器立即发送更新消息，其他路由器收到更新消息后立即进行路由计算，快速完成收敛。</p>
<h2 id="OSPF认证机制"><a href="#OSPF认证机制" class="headerlink" title="OSPF认证机制"></a>OSPF认证机制</h2><h3 id="安全隐患"><a href="#安全隐患" class="headerlink" title="安全隐患"></a>安全隐患</h3><p><img src="/../../images/OSPF/%E5%AE%89%E5%85%A8%E9%9A%90%E6%82%A3.png"></p>
<p>如图所示，内部网络通过OSPF协议传递路由。正常情况下，财务部访问公司数据库的流量走向是 <code>财务部-&gt;RTA-&gt;RTB-&gt;Database</code>。</p>
<p>非法设备接入公司内网，通过向网络中注入非法路由，引导流量进行非正常的转发。即 <code>财务部-&gt;RTA-&gt;非法设备-&gt;RTB-&gt;Database</code>。非法设备收到财务部的流量之后，进行恶意分析，获取财务部关键信息，造成公司机密泄露。</p>
<h3 id="安全认证"><a href="#安全认证" class="headerlink" title="安全认证"></a>安全认证</h3><p><img src="/../../images/OSPF/%E5%AE%89%E5%85%A8%E8%AE%A4%E8%AF%81.png"></p>
<p>OSPF支持认证功能，只有通过认证的OSPF路由器才能正常建立邻居关系，交互信息</p>
<p>两种认证方式︰</p>
<ul>
<li>区域认证方式</li>
<li>接口认证方式。</li>
</ul>
<p>支持的认证模式分为null (不认证)、simple（明文)、MD5以及HMAC-MD5。</p>
<p>当两种认证方式都存在时，优先使用接口认证方式。</p>
<h2 id="综合应用"><a href="#综合应用" class="headerlink" title="综合应用"></a>综合应用</h2><p><img src="/../../images/OSPF/ospf%E7%BB%BC%E5%90%88%E5%BA%94%E7%94%A8.png"></p>
<ul>
<li>需求1分析︰办事处C处于Area 3，RTE左侧与Area 2相连。根据OSPF骨干区域与非骨干区域的连接规则，不能正常通行的原因在于Area 3没有与Area 0直接相连。解决的方式是在RTE和RTC之间建立虚连接。</li>
<li>需求2分析︰区域内部设备性能低，降低路由计算压力可以通过Stub、Totally Stub、NSSA、Totally NSSA，最大程度减少需要选择Totally Stub或Totally NSSA，同时为了保留外部路由引入的功能，只能选择Totally NSSA。</li>
<li>需求3分析∶保证路由安全性需要通过认证的方式，最安全的认证模式是采用HMAC-MD5。认证形式采取接口认证。</li>
<li>需求4分析∶在计算外部路由时如要考虑OSPF域内开销，可通过引入类型为1类的外部路由实现。</li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><img src="/../../images/OSPF/%E7%BB%BC%E5%90%88%E5%BA%94%E7%94%A8%E5%AE%9E%E7%8E%B01.png"></p>
<p><img src="/../../images/OSPF/%E7%BB%BC%E5%90%88%E5%BA%94%E7%94%A8%E5%AE%9E%E7%8E%B02.png"></p>
]]></content>
      <tags>
        <tag>网络-理论</tag>
      </tags>
  </entry>
  <entry>
    <title>前端工程师职业规划参考</title>
    <url>/2023/07/02/%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92%E5%8F%82%E8%80%83/</url>
    <content><![CDATA[<h3 id="1-初级前端工程师（1-2年）："><a href="#1-初级前端工程师（1-2年）：" class="headerlink" title="1. 初级前端工程师（1-2年）："></a>1. 初级前端工程师（1-2年）：</h3><ul>
<li>学习HTML、CSS和JavaScript等基础知识，并熟练运用它们进行网页开发。</li>
<li>参与项目团队，积累实际项目经验。</li>
<li>学习和掌握常用的前端框架和工具，如React、Vue.js、Webpack等。</li>
<li>参与培训课程和技术社区，不断学习和提升技能。</li>
</ul>
<h3 id="2-中级前端工程师（3-5年）："><a href="#2-中级前端工程师（3-5年）：" class="headerlink" title="2. 中级前端工程师（3-5年）："></a>2. 中级前端工程师（3-5年）：</h3><ul>
<li>在项目中承担更复杂的前端开发任务，如开发响应式网站、移动端应用等。</li>
<li>深入学习和掌握前端框架和库的原理和使用技巧。</li>
<li>学习和应用前端最佳实践，如性能优化、代码规范等。</li>
<li>参与团队协作和项目管理，提升沟通和领导能力。</li>
</ul>
<h3 id="3-高级前端工程师（5年以上）："><a href="#3-高级前端工程师（5年以上）：" class="headerlink" title="3. 高级前端工程师（5年以上）："></a>3. 高级前端工程师（5年以上）：</h3><ul>
<li>在复杂项目中担任技术负责人或架构师角色，负责前端架构设计和技术选型。</li>
<li>深入研究前端领域的新技术和趋势，并引领团队进行技术创新和实践。</li>
<li>参与开源项目和技术社区，分享经验和贡献代码。</li>
<li>建立自己的技术品牌和影响力，如通过博客、演讲等方式分享经验和见解。</li>
</ul>
<h3 id="4-职业发展方向："><a href="#4-职业发展方向：" class="headerlink" title="4. 职业发展方向："></a>4. 职业发展方向：</h3><ul>
<li>前端架构师：专注于前端架构设计和技术选型，负责复杂项目的技术规划和架构设计。</li>
<li>前端团队管理：发展管理和领导能力，负责前端团队的招聘、培训和项目管理。</li>
<li>UX&#x2F;UI设计师：学习和掌握用户体验和界面设计的知识，负责前端界面设计和交互优化。</li>
<li>技术顾问：通过积累丰富的经验和知识，为企业提供前端技术咨询和解决方案。</li>
</ul>
<p>这只是一个参考，可以根据自己的兴趣和职业目标进行调整和补充。重要的是制定一个明确的职业规划，并不断学习和发展自己的技能，以实现职业的持续成长和发展。</p>
]]></content>
      <tags>
        <tag>职业规划</tag>
      </tags>
  </entry>
  <entry>
    <title>后端工程师职业规划参考</title>
    <url>/2023/07/02/%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/%E5%90%8E%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92%E5%8F%82%E8%80%83/</url>
    <content><![CDATA[<h3 id="1-初级后端工程师（1-3年）："><a href="#1-初级后端工程师（1-3年）：" class="headerlink" title="1. 初级后端工程师（1-3年）："></a>1. 初级后端工程师（1-3年）：</h3><ul>
<li>掌握一门主流后端开发语言，如Java、Python或Node.js。</li>
<li>学习并应用常见的后端开发框架和技术，如Spring、Django或Express.js。</li>
<li>参与项目开发，负责后端功能的实现和数据库设计。</li>
<li>学习和应用基本的软件工程原则和最佳实践。</li>
<li>持续学习和提升编程和问题解决能力。</li>
</ul>
<h3 id="2-中级后端工程师（3-5年）："><a href="#2-中级后端工程师（3-5年）：" class="headerlink" title="2. 中级后端工程师（3-5年）："></a>2. 中级后端工程师（3-5年）：</h3><ul>
<li>深入研究和应用后端开发技术栈，如数据库优化、性能调优、缓存等。</li>
<li>参与设计和开发复杂的后端系统，包括分布式系统和微服务架构。</li>
<li>学习和应用设计模式和架构原则，提高系统的可扩展性和可维护性。</li>
<li>参与团队的技术选型和架构设计，负责解决技术难题和挑战。</li>
<li>培养团队合作和沟通能力，开始指导和培养初级工程师。</li>
</ul>
<h3 id="3-高级后端工程师（5年以上）："><a href="#3-高级后端工程师（5年以上）：" class="headerlink" title="3. 高级后端工程师（5年以上）："></a>3. 高级后端工程师（5年以上）：</h3><ul>
<li>深入研究和应用领域专有的后端技术，如金融领域的支付系统、电子商务领域的订单处理系统等。</li>
<li>参与大型项目的架构设计和技术规划，负责解决复杂的技术挑战。</li>
<li>深入理解和应用云计算和容器化技术，如Docker和Kubernetes。</li>
<li>参与行业内的研究和交流，提升自己在该领域的专业影响力。</li>
<li>培养和指导团队成员的技术能力和职业发展。</li>
</ul>
<h3 id="4-技术管理者："><a href="#4-技术管理者：" class="headerlink" title="4. 技术管理者："></a>4. 技术管理者：</h3><ul>
<li>学习项目管理和团队管理知识，培养领导力和沟通能力。</li>
<li>担任技术团队的领导角色，负责项目的规划和执行。</li>
<li>帮助团队成员制定个人的职业规划，并提供指导和支持。</li>
<li>参与公司的技术战略规划和决策，推动团队的技术创新和发展。</li>
</ul>
]]></content>
      <tags>
        <tag>职业规划</tag>
      </tags>
  </entry>
  <entry>
    <title>网络工程师职业规划参考</title>
    <url>/2023/07/02/%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92%E5%8F%82%E8%80%83/</url>
    <content><![CDATA[<h3 id="1-初级网络工程师（1-2年）："><a href="#1-初级网络工程师（1-2年）：" class="headerlink" title="1. 初级网络工程师（1-2年）："></a>1. 初级网络工程师（1-2年）：</h3><ul>
<li>学习和掌握计算机网络的基础知识，如TCP&#x2F;IP协议、网络拓扑等。</li>
<li>熟悉常用的网络设备和工具，如交换机、路由器、网络监控软件等。</li>
<li>参与网络设备的配置和维护工作，解决常见的网络故障和问题。</li>
<li>学习和掌握网络安全的基础知识，如防火墙、VPN等。</li>
</ul>
<h3 id="2-中级网络工程师（3-5年）："><a href="#2-中级网络工程师（3-5年）：" class="headerlink" title="2. 中级网络工程师（3-5年）："></a>2. 中级网络工程师（3-5年）：</h3><ul>
<li>参与大型网络项目的规划和实施，如企业网络升级、数据中心建设等。</li>
<li>深入学习和掌握网络技术的高级知识，如VLAN、路由协议、负载均衡等。</li>
<li>学习和应用网络性能优化的技术和方法，提高网络的稳定性和响应速度。</li>
<li>参与网络安全方面的工作，如网络漏洞扫描、入侵检测等。</li>
</ul>
<h3 id="3-高级网络工程师（5年以上）："><a href="#3-高级网络工程师（5年以上）：" class="headerlink" title="3. 高级网络工程师（5年以上）："></a>3. 高级网络工程师（5年以上）：</h3><ul>
<li>在复杂网络环境下担任技术负责人或架构师角色，负责网络架构设计和规划。</li>
<li>深入研究网络领域的新技术和趋势，并引领团队进行技术创新和实践。</li>
<li>参与网络安全的高级工作，如安全策略制定、事件响应等。</li>
<li>建立自己的技术品牌和影响力，如通过博客、演讲等方式分享经验和见解。</li>
</ul>
<h3 id="4-职业发展方向："><a href="#4-职业发展方向：" class="headerlink" title="4. 职业发展方向："></a>4. 职业发展方向：</h3><ul>
<li>网络架构师：专注于网络架构设计和规划，负责复杂网络项目的技术规划和架构设计。</li>
<li>网络安全专家：深入研究网络安全领域，负责企业的网络安全策略和漏洞修复。</li>
<li>云计算工程师：学习和掌握云计算和虚拟化技术，负责企业的云平台建设和管理。</li>
<li>网络运维经理：发展管理和领导能力，负责网络团队的招聘、培训和运维管理。</li>
</ul>
<p>这只是一个参考，可以根据自己的兴趣和职业目标进行调整和补充。重要的是制定一个明确的职业规划，并不断学习和发展自己的技能，以实现职业的持续成长和发展。</p>
]]></content>
      <tags>
        <tag>职业规划</tag>
      </tags>
  </entry>
  <entry>
    <title>软件测试工程师职业规划参考</title>
    <url>/2023/07/02/%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h3 id="1-初级软件测试工程师（1-2年）："><a href="#1-初级软件测试工程师（1-2年）：" class="headerlink" title="1. 初级软件测试工程师（1-2年）："></a>1. 初级软件测试工程师（1-2年）：</h3><ul>
<li>学习和掌握软件测试的基础知识，如测试方法、测试文档编写等。</li>
<li>熟悉常用的测试工具和技术，如自动化测试工具、性能测试工具等。</li>
<li>参与软件测试项目，执行测试计划、编写测试用例、执行测试并记录缺陷。</li>
</ul>
<h3 id="2-中级软件测试工程师（3-5年）："><a href="#2-中级软件测试工程师（3-5年）：" class="headerlink" title="2. 中级软件测试工程师（3-5年）："></a>2. 中级软件测试工程师（3-5年）：</h3><ul>
<li>深入学习和掌握软件测试的高级知识，如测试策略、测试环境配置等。</li>
<li>参与复杂软件项目的测试规划和设计，提出测试方案和策略。</li>
<li>掌握自动化测试技术，编写和执行自动化测试脚本，提高测试效率和质量。</li>
<li>学习和应用性能测试和安全测试的技术，提高软件的性能和安全性。</li>
</ul>
<h3 id="3-高级软件测试工程师（5年以上）："><a href="#3-高级软件测试工程师（5年以上）：" class="headerlink" title="3. 高级软件测试工程师（5年以上）："></a>3. 高级软件测试工程师（5年以上）：</h3><ul>
<li>在复杂项目中担任测试团队的技术负责人或测试架构师角色。</li>
<li>深入研究软件测试领域的新技术和趋势，并引领团队进行技术创新和实践。</li>
<li>参与软件质量管理方面的工作，如质量度量、过程改进等。</li>
<li>建立自己的技术品牌和影响力，如通过博客、演讲等方式分享经验和见解。</li>
</ul>
<h3 id="4-职业发展方向："><a href="#4-职业发展方向：" class="headerlink" title="4. 职业发展方向："></a>4. 职业发展方向：</h3><ul>
<li>质量保证经理：发展管理和领导能力，负责整个软件质量保证流程的管理和改进。</li>
<li>自动化测试专家：深入研究自动化测试技术和工具，负责团队的自动化测试实施。</li>
<li>安全测试专家：学习和掌握安全测试的知识和技术，负责软件安全测试和漏洞修复。</li>
<li>敏捷测试专家：学习和掌握敏捷开发和测试方法，负责敏捷团队的测试工作。</li>
</ul>
]]></content>
      <tags>
        <tag>职业规划</tag>
      </tags>
  </entry>
</search>
